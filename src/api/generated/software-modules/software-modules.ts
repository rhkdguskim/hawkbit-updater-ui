/**
 * Generated by orval v7.17.0 üç∫
 * Do not edit manually.
 * hawkBit REST APIs
 * Eclipse hawkBit‚Ñ¢ is a domain-independent back-end framework for rolling out software updates to constrained edge devices as well as more powerful controllers and gateways connected to IP based networking infrastructure.

 * OpenAPI spec version: v1
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  ExceptionInfo,
  GetArtifactParams,
  GetArtifactsParams,
  GetMetadata1Params,
  GetSoftwareModulesParams,
  MgmtArtifact,
  MgmtSoftwareModule,
  MgmtSoftwareModuleMetadata,
  MgmtSoftwareModuleMetadataBodyPut,
  MgmtSoftwareModuleRequestBodyPost,
  MgmtSoftwareModuleRequestBodyPut,
  PagedListMgmtSoftwareModule,
  PagedListMgmtSoftwareModuleMetadata,
  UploadArtifactBody,
  UploadArtifactParams
} from '.././model';

import { axiosInstance } from '../../axios-instance';


type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * Handles the GET request of retrieving a single softwaremodule. Required Permission: READ_REPOSITORY
 * @summary Return Software Module by id
 */
export const getSoftwareModule = (
    softwareModuleId: number,
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      
      
      return axiosInstance<MgmtSoftwareModule>(
      {url: `/rest/v1/softwaremodules/${softwareModuleId}`, method: 'GET', signal
    },
      options);
    }
  



export const getGetSoftwareModuleQueryKey = (softwareModuleId?: number,) => {
    return [
    `/rest/v1/softwaremodules/${softwareModuleId}`
    ] as const;
    }

    
export const getGetSoftwareModuleQueryOptions = <TData = Awaited<ReturnType<typeof getSoftwareModule>>, TError = ExceptionInfo>(softwareModuleId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSoftwareModule>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSoftwareModuleQueryKey(softwareModuleId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSoftwareModule>>> = ({ signal }) => getSoftwareModule(softwareModuleId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(softwareModuleId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getSoftwareModule>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetSoftwareModuleQueryResult = NonNullable<Awaited<ReturnType<typeof getSoftwareModule>>>
export type GetSoftwareModuleQueryError = ExceptionInfo


export function useGetSoftwareModule<TData = Awaited<ReturnType<typeof getSoftwareModule>>, TError = ExceptionInfo>(
 softwareModuleId: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSoftwareModule>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSoftwareModule>>,
          TError,
          Awaited<ReturnType<typeof getSoftwareModule>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSoftwareModule<TData = Awaited<ReturnType<typeof getSoftwareModule>>, TError = ExceptionInfo>(
 softwareModuleId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSoftwareModule>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSoftwareModule>>,
          TError,
          Awaited<ReturnType<typeof getSoftwareModule>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSoftwareModule<TData = Awaited<ReturnType<typeof getSoftwareModule>>, TError = ExceptionInfo>(
 softwareModuleId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSoftwareModule>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Return Software Module by id
 */

export function useGetSoftwareModule<TData = Awaited<ReturnType<typeof getSoftwareModule>>, TError = ExceptionInfo>(
 softwareModuleId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSoftwareModule>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetSoftwareModuleQueryOptions(softwareModuleId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Handles the PUT request for a single softwaremodule within Hawkbit. Required Permission: UPDATE_REPOSITORY
 * @summary Update Software Module
 */
export const updateSoftwareModule = (
    softwareModuleId: number,
    mgmtSoftwareModuleRequestBodyPut: MgmtSoftwareModuleRequestBodyPut,
 options?: SecondParameter<typeof axiosInstance>,) => {
      
      
      return axiosInstance<MgmtSoftwareModule>(
      {url: `/rest/v1/softwaremodules/${softwareModuleId}`, method: 'PUT',
      headers: {'Content-Type': 'application/hal+json', },
      data: mgmtSoftwareModuleRequestBodyPut
    },
      options);
    }
  


export const getUpdateSoftwareModuleMutationOptions = <TError = ExceptionInfo,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateSoftwareModule>>, TError,{softwareModuleId: number;data: MgmtSoftwareModuleRequestBodyPut}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updateSoftwareModule>>, TError,{softwareModuleId: number;data: MgmtSoftwareModuleRequestBodyPut}, TContext> => {

const mutationKey = ['updateSoftwareModule'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateSoftwareModule>>, {softwareModuleId: number;data: MgmtSoftwareModuleRequestBodyPut}> = (props) => {
          const {softwareModuleId,data} = props ?? {};

          return  updateSoftwareModule(softwareModuleId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateSoftwareModuleMutationResult = NonNullable<Awaited<ReturnType<typeof updateSoftwareModule>>>
    export type UpdateSoftwareModuleMutationBody = MgmtSoftwareModuleRequestBodyPut
    export type UpdateSoftwareModuleMutationError = ExceptionInfo

    /**
 * @summary Update Software Module
 */
export const useUpdateSoftwareModule = <TError = ExceptionInfo,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateSoftwareModule>>, TError,{softwareModuleId: number;data: MgmtSoftwareModuleRequestBodyPut}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateSoftwareModule>>,
        TError,
        {softwareModuleId: number;data: MgmtSoftwareModuleRequestBodyPut},
        TContext
      > => {

      const mutationOptions = getUpdateSoftwareModuleMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Handles the DELETE request for a single softwaremodule within Hawkbit. Required Permission: DELETE_REPOSITORY
 * @summary Delete Software Module by Id
 */
export const deleteSoftwareModule = (
    softwareModuleId: number,
 options?: SecondParameter<typeof axiosInstance>,) => {
      
      
      return axiosInstance<void>(
      {url: `/rest/v1/softwaremodules/${softwareModuleId}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteSoftwareModuleMutationOptions = <TError = ExceptionInfo,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteSoftwareModule>>, TError,{softwareModuleId: number}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteSoftwareModule>>, TError,{softwareModuleId: number}, TContext> => {

const mutationKey = ['deleteSoftwareModule'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteSoftwareModule>>, {softwareModuleId: number}> = (props) => {
          const {softwareModuleId} = props ?? {};

          return  deleteSoftwareModule(softwareModuleId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteSoftwareModuleMutationResult = NonNullable<Awaited<ReturnType<typeof deleteSoftwareModule>>>
    
    export type DeleteSoftwareModuleMutationError = ExceptionInfo

    /**
 * @summary Delete Software Module by Id
 */
export const useDeleteSoftwareModule = <TError = ExceptionInfo,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteSoftwareModule>>, TError,{softwareModuleId: number}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteSoftwareModule>>,
        TError,
        {softwareModuleId: number},
        TContext
      > => {

      const mutationOptions = getDeleteSoftwareModuleMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Get a single metadata value for a metadata key. Required Permission: READ_REPOSITORY
 * @summary Return single metadata value for a specific key of a Software Module
 */
export const getMetadataValue1 = (
    softwareModuleId: number,
    metadataKey: string,
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      
      
      return axiosInstance<MgmtSoftwareModuleMetadata>(
      {url: `/rest/v1/softwaremodules/${softwareModuleId}/metadata/${metadataKey}`, method: 'GET', signal
    },
      options);
    }
  



export const getGetMetadataValue1QueryKey = (softwareModuleId?: number,
    metadataKey?: string,) => {
    return [
    `/rest/v1/softwaremodules/${softwareModuleId}/metadata/${metadataKey}`
    ] as const;
    }

    
export const getGetMetadataValue1QueryOptions = <TData = Awaited<ReturnType<typeof getMetadataValue1>>, TError = ExceptionInfo>(softwareModuleId: number,
    metadataKey: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMetadataValue1>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMetadataValue1QueryKey(softwareModuleId,metadataKey);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMetadataValue1>>> = ({ signal }) => getMetadataValue1(softwareModuleId,metadataKey, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(softwareModuleId && metadataKey), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMetadataValue1>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetMetadataValue1QueryResult = NonNullable<Awaited<ReturnType<typeof getMetadataValue1>>>
export type GetMetadataValue1QueryError = ExceptionInfo


export function useGetMetadataValue1<TData = Awaited<ReturnType<typeof getMetadataValue1>>, TError = ExceptionInfo>(
 softwareModuleId: number,
    metadataKey: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMetadataValue1>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMetadataValue1>>,
          TError,
          Awaited<ReturnType<typeof getMetadataValue1>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetMetadataValue1<TData = Awaited<ReturnType<typeof getMetadataValue1>>, TError = ExceptionInfo>(
 softwareModuleId: number,
    metadataKey: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMetadataValue1>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMetadataValue1>>,
          TError,
          Awaited<ReturnType<typeof getMetadataValue1>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetMetadataValue1<TData = Awaited<ReturnType<typeof getMetadataValue1>>, TError = ExceptionInfo>(
 softwareModuleId: number,
    metadataKey: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMetadataValue1>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Return single metadata value for a specific key of a Software Module
 */

export function useGetMetadataValue1<TData = Awaited<ReturnType<typeof getMetadataValue1>>, TError = ExceptionInfo>(
 softwareModuleId: number,
    metadataKey: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMetadataValue1>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetMetadataValue1QueryOptions(softwareModuleId,metadataKey,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update a single metadata value for speficic key. Required Permission: UPDATE_REPOSITORY
 * @summary Update a single metadata value of a Software Module
 */
export const updateMetadata1 = (
    softwareModuleId: number,
    metadataKey: string,
    mgmtSoftwareModuleMetadataBodyPut: MgmtSoftwareModuleMetadataBodyPut,
 options?: SecondParameter<typeof axiosInstance>,) => {
      
      
      return axiosInstance<MgmtSoftwareModuleMetadata>(
      {url: `/rest/v1/softwaremodules/${softwareModuleId}/metadata/${metadataKey}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: mgmtSoftwareModuleMetadataBodyPut
    },
      options);
    }
  


export const getUpdateMetadata1MutationOptions = <TError = ExceptionInfo,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateMetadata1>>, TError,{softwareModuleId: number;metadataKey: string;data: MgmtSoftwareModuleMetadataBodyPut}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updateMetadata1>>, TError,{softwareModuleId: number;metadataKey: string;data: MgmtSoftwareModuleMetadataBodyPut}, TContext> => {

const mutationKey = ['updateMetadata1'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateMetadata1>>, {softwareModuleId: number;metadataKey: string;data: MgmtSoftwareModuleMetadataBodyPut}> = (props) => {
          const {softwareModuleId,metadataKey,data} = props ?? {};

          return  updateMetadata1(softwareModuleId,metadataKey,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateMetadata1MutationResult = NonNullable<Awaited<ReturnType<typeof updateMetadata1>>>
    export type UpdateMetadata1MutationBody = MgmtSoftwareModuleMetadataBodyPut
    export type UpdateMetadata1MutationError = ExceptionInfo

    /**
 * @summary Update a single metadata value of a Software Module
 */
export const useUpdateMetadata1 = <TError = ExceptionInfo,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateMetadata1>>, TError,{softwareModuleId: number;metadataKey: string;data: MgmtSoftwareModuleMetadataBodyPut}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateMetadata1>>,
        TError,
        {softwareModuleId: number;metadataKey: string;data: MgmtSoftwareModuleMetadataBodyPut},
        TContext
      > => {

      const mutationOptions = getUpdateMetadata1MutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Delete a single metadata. Required Permission: UPDATE_REPOSITORY
 * @summary Delete single metadata entry from the software module
 */
export const deleteMetadata1 = (
    softwareModuleId: number,
    metadataKey: string,
 options?: SecondParameter<typeof axiosInstance>,) => {
      
      
      return axiosInstance<void>(
      {url: `/rest/v1/softwaremodules/${softwareModuleId}/metadata/${metadataKey}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteMetadata1MutationOptions = <TError = ExceptionInfo,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteMetadata1>>, TError,{softwareModuleId: number;metadataKey: string}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteMetadata1>>, TError,{softwareModuleId: number;metadataKey: string}, TContext> => {

const mutationKey = ['deleteMetadata1'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteMetadata1>>, {softwareModuleId: number;metadataKey: string}> = (props) => {
          const {softwareModuleId,metadataKey} = props ?? {};

          return  deleteMetadata1(softwareModuleId,metadataKey,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteMetadata1MutationResult = NonNullable<Awaited<ReturnType<typeof deleteMetadata1>>>
    
    export type DeleteMetadata1MutationError = ExceptionInfo

    /**
 * @summary Delete single metadata entry from the software module
 */
export const useDeleteMetadata1 = <TError = ExceptionInfo,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteMetadata1>>, TError,{softwareModuleId: number;metadataKey: string}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteMetadata1>>,
        TError,
        {softwareModuleId: number;metadataKey: string},
        TContext
      > => {

      const mutationOptions = getDeleteMetadata1MutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Handles the GET request of retrieving all softwaremodules. Required Permission: READ_REPOSITORY
 * @summary Return all Software modules
 */
export const getSoftwareModules = (
    params?: GetSoftwareModulesParams,
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      
      
      return axiosInstance<PagedListMgmtSoftwareModule>(
      {url: `/rest/v1/softwaremodules`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getGetSoftwareModulesQueryKey = (params?: GetSoftwareModulesParams,) => {
    return [
    `/rest/v1/softwaremodules`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetSoftwareModulesQueryOptions = <TData = Awaited<ReturnType<typeof getSoftwareModules>>, TError = ExceptionInfo>(params?: GetSoftwareModulesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSoftwareModules>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSoftwareModulesQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSoftwareModules>>> = ({ signal }) => getSoftwareModules(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getSoftwareModules>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetSoftwareModulesQueryResult = NonNullable<Awaited<ReturnType<typeof getSoftwareModules>>>
export type GetSoftwareModulesQueryError = ExceptionInfo


export function useGetSoftwareModules<TData = Awaited<ReturnType<typeof getSoftwareModules>>, TError = ExceptionInfo>(
 params: undefined |  GetSoftwareModulesParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSoftwareModules>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSoftwareModules>>,
          TError,
          Awaited<ReturnType<typeof getSoftwareModules>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSoftwareModules<TData = Awaited<ReturnType<typeof getSoftwareModules>>, TError = ExceptionInfo>(
 params?: GetSoftwareModulesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSoftwareModules>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSoftwareModules>>,
          TError,
          Awaited<ReturnType<typeof getSoftwareModules>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSoftwareModules<TData = Awaited<ReturnType<typeof getSoftwareModules>>, TError = ExceptionInfo>(
 params?: GetSoftwareModulesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSoftwareModules>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Return all Software modules
 */

export function useGetSoftwareModules<TData = Awaited<ReturnType<typeof getSoftwareModules>>, TError = ExceptionInfo>(
 params?: GetSoftwareModulesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSoftwareModules>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetSoftwareModulesQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Handles the POST request of creating new software modules. The request body must always be a list of modules. Required Permission: CREATE_REPOSITORY
 * @summary Create Software Module(s)
 */
export const createSoftwareModules = (
    mgmtSoftwareModuleRequestBodyPost: MgmtSoftwareModuleRequestBodyPost[],
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      
      
      return axiosInstance<MgmtSoftwareModule[]>(
      {url: `/rest/v1/softwaremodules`, method: 'POST',
      headers: {'Content-Type': 'application/hal+json', },
      data: mgmtSoftwareModuleRequestBodyPost, signal
    },
      options);
    }
  


export const getCreateSoftwareModulesMutationOptions = <TError = ExceptionInfo,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createSoftwareModules>>, TError,{data: MgmtSoftwareModuleRequestBodyPost[]}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createSoftwareModules>>, TError,{data: MgmtSoftwareModuleRequestBodyPost[]}, TContext> => {

const mutationKey = ['createSoftwareModules'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createSoftwareModules>>, {data: MgmtSoftwareModuleRequestBodyPost[]}> = (props) => {
          const {data} = props ?? {};

          return  createSoftwareModules(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateSoftwareModulesMutationResult = NonNullable<Awaited<ReturnType<typeof createSoftwareModules>>>
    export type CreateSoftwareModulesMutationBody = MgmtSoftwareModuleRequestBodyPost[]
    export type CreateSoftwareModulesMutationError = ExceptionInfo

    /**
 * @summary Create Software Module(s)
 */
export const useCreateSoftwareModules = <TError = ExceptionInfo,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createSoftwareModules>>, TError,{data: MgmtSoftwareModuleRequestBodyPost[]}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createSoftwareModules>>,
        TError,
        {data: MgmtSoftwareModuleRequestBodyPost[]},
        TContext
      > => {

      const mutationOptions = getCreateSoftwareModulesMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Get a paged list of metadata for a software module. Required Permission: READ_REPOSITORY
 * @summary Return metadata for a Software Module
 */
export const getMetadata1 = (
    softwareModuleId: number,
    params?: GetMetadata1Params,
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      
      
      return axiosInstance<PagedListMgmtSoftwareModuleMetadata>(
      {url: `/rest/v1/softwaremodules/${softwareModuleId}/metadata`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getGetMetadata1QueryKey = (softwareModuleId?: number,
    params?: GetMetadata1Params,) => {
    return [
    `/rest/v1/softwaremodules/${softwareModuleId}/metadata`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetMetadata1QueryOptions = <TData = Awaited<ReturnType<typeof getMetadata1>>, TError = ExceptionInfo>(softwareModuleId: number,
    params?: GetMetadata1Params, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMetadata1>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMetadata1QueryKey(softwareModuleId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMetadata1>>> = ({ signal }) => getMetadata1(softwareModuleId,params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(softwareModuleId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMetadata1>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetMetadata1QueryResult = NonNullable<Awaited<ReturnType<typeof getMetadata1>>>
export type GetMetadata1QueryError = ExceptionInfo


export function useGetMetadata1<TData = Awaited<ReturnType<typeof getMetadata1>>, TError = ExceptionInfo>(
 softwareModuleId: number,
    params: undefined |  GetMetadata1Params, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMetadata1>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMetadata1>>,
          TError,
          Awaited<ReturnType<typeof getMetadata1>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetMetadata1<TData = Awaited<ReturnType<typeof getMetadata1>>, TError = ExceptionInfo>(
 softwareModuleId: number,
    params?: GetMetadata1Params, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMetadata1>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMetadata1>>,
          TError,
          Awaited<ReturnType<typeof getMetadata1>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetMetadata1<TData = Awaited<ReturnType<typeof getMetadata1>>, TError = ExceptionInfo>(
 softwareModuleId: number,
    params?: GetMetadata1Params, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMetadata1>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Return metadata for a Software Module
 */

export function useGetMetadata1<TData = Awaited<ReturnType<typeof getMetadata1>>, TError = ExceptionInfo>(
 softwareModuleId: number,
    params?: GetMetadata1Params, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMetadata1>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetMetadata1QueryOptions(softwareModuleId,params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Create a list of metadata entries Required Permission: UPDATE_REPOSITORY
 * @summary Creates a list of metadata for a specific Software Module
 */
export const createMetadata1 = (
    softwareModuleId: number,
    mgmtSoftwareModuleMetadata: MgmtSoftwareModuleMetadata[],
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      
      
      return axiosInstance<MgmtSoftwareModuleMetadata[]>(
      {url: `/rest/v1/softwaremodules/${softwareModuleId}/metadata`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: mgmtSoftwareModuleMetadata, signal
    },
      options);
    }
  


export const getCreateMetadata1MutationOptions = <TError = ExceptionInfo,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createMetadata1>>, TError,{softwareModuleId: number;data: MgmtSoftwareModuleMetadata[]}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createMetadata1>>, TError,{softwareModuleId: number;data: MgmtSoftwareModuleMetadata[]}, TContext> => {

const mutationKey = ['createMetadata1'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createMetadata1>>, {softwareModuleId: number;data: MgmtSoftwareModuleMetadata[]}> = (props) => {
          const {softwareModuleId,data} = props ?? {};

          return  createMetadata1(softwareModuleId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateMetadata1MutationResult = NonNullable<Awaited<ReturnType<typeof createMetadata1>>>
    export type CreateMetadata1MutationBody = MgmtSoftwareModuleMetadata[]
    export type CreateMetadata1MutationError = ExceptionInfo

    /**
 * @summary Creates a list of metadata for a specific Software Module
 */
export const useCreateMetadata1 = <TError = ExceptionInfo,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createMetadata1>>, TError,{softwareModuleId: number;data: MgmtSoftwareModuleMetadata[]}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createMetadata1>>,
        TError,
        {softwareModuleId: number;data: MgmtSoftwareModuleMetadata[]},
        TContext
      > => {

      const mutationOptions = getCreateMetadata1MutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Handles the GET request of retrieving all metadata of artifacts assigned to a software module. Required Permission: READ_REPOSITORY
 * @summary Return all metadata of artifacts assigned to a software module
 */
export const getArtifacts = (
    softwareModuleId: number,
    params?: GetArtifactsParams,
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      
      
      return axiosInstance<MgmtArtifact[]>(
      {url: `/rest/v1/softwaremodules/${softwareModuleId}/artifacts`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getGetArtifactsQueryKey = (softwareModuleId?: number,
    params?: GetArtifactsParams,) => {
    return [
    `/rest/v1/softwaremodules/${softwareModuleId}/artifacts`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetArtifactsQueryOptions = <TData = Awaited<ReturnType<typeof getArtifacts>>, TError = ExceptionInfo>(softwareModuleId: number,
    params?: GetArtifactsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getArtifacts>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetArtifactsQueryKey(softwareModuleId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getArtifacts>>> = ({ signal }) => getArtifacts(softwareModuleId,params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(softwareModuleId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getArtifacts>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetArtifactsQueryResult = NonNullable<Awaited<ReturnType<typeof getArtifacts>>>
export type GetArtifactsQueryError = ExceptionInfo


export function useGetArtifacts<TData = Awaited<ReturnType<typeof getArtifacts>>, TError = ExceptionInfo>(
 softwareModuleId: number,
    params: undefined |  GetArtifactsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getArtifacts>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getArtifacts>>,
          TError,
          Awaited<ReturnType<typeof getArtifacts>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetArtifacts<TData = Awaited<ReturnType<typeof getArtifacts>>, TError = ExceptionInfo>(
 softwareModuleId: number,
    params?: GetArtifactsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getArtifacts>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getArtifacts>>,
          TError,
          Awaited<ReturnType<typeof getArtifacts>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetArtifacts<TData = Awaited<ReturnType<typeof getArtifacts>>, TError = ExceptionInfo>(
 softwareModuleId: number,
    params?: GetArtifactsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getArtifacts>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Return all metadata of artifacts assigned to a software module
 */

export function useGetArtifacts<TData = Awaited<ReturnType<typeof getArtifacts>>, TError = ExceptionInfo>(
 softwareModuleId: number,
    params?: GetArtifactsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getArtifacts>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetArtifactsQueryOptions(softwareModuleId,params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Handles POST request for artifact upload. Required Permission: CREATE_REPOSITORY
 * @summary Upload artifact
 */
export const uploadArtifact = (
    softwareModuleId: number,
    uploadArtifactBody: UploadArtifactBody,
    params?: UploadArtifactParams,
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      
      const formData = new FormData();
formData.append(`file`, uploadArtifactBody.file)

      return axiosInstance<MgmtArtifact>(
      {url: `/rest/v1/softwaremodules/${softwareModuleId}/artifacts`, method: 'POST',
      headers: {'Content-Type': 'multipart/form-data', },
       data: formData,
        params, signal
    },
      options);
    }
  


export const getUploadArtifactMutationOptions = <TError = ExceptionInfo,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof uploadArtifact>>, TError,{softwareModuleId: number;data: UploadArtifactBody;params?: UploadArtifactParams}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof uploadArtifact>>, TError,{softwareModuleId: number;data: UploadArtifactBody;params?: UploadArtifactParams}, TContext> => {

const mutationKey = ['uploadArtifact'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof uploadArtifact>>, {softwareModuleId: number;data: UploadArtifactBody;params?: UploadArtifactParams}> = (props) => {
          const {softwareModuleId,data,params} = props ?? {};

          return  uploadArtifact(softwareModuleId,data,params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UploadArtifactMutationResult = NonNullable<Awaited<ReturnType<typeof uploadArtifact>>>
    export type UploadArtifactMutationBody = UploadArtifactBody
    export type UploadArtifactMutationError = ExceptionInfo

    /**
 * @summary Upload artifact
 */
export const useUploadArtifact = <TError = ExceptionInfo,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof uploadArtifact>>, TError,{softwareModuleId: number;data: UploadArtifactBody;params?: UploadArtifactParams}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof uploadArtifact>>,
        TError,
        {softwareModuleId: number;data: UploadArtifactBody;params?: UploadArtifactParams},
        TContext
      > => {

      const mutationOptions = getUploadArtifactMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Handles the GET request of retrieving a single Artifact metadata request. Required Permission: READ_REPOSITORY
 * @summary Return single Artifact metadata
 */
export const getArtifact = (
    softwareModuleId: number,
    artifactId: number,
    params?: GetArtifactParams,
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      
      
      return axiosInstance<MgmtArtifact>(
      {url: `/rest/v1/softwaremodules/${softwareModuleId}/artifacts/${artifactId}`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getGetArtifactQueryKey = (softwareModuleId?: number,
    artifactId?: number,
    params?: GetArtifactParams,) => {
    return [
    `/rest/v1/softwaremodules/${softwareModuleId}/artifacts/${artifactId}`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetArtifactQueryOptions = <TData = Awaited<ReturnType<typeof getArtifact>>, TError = ExceptionInfo>(softwareModuleId: number,
    artifactId: number,
    params?: GetArtifactParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getArtifact>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetArtifactQueryKey(softwareModuleId,artifactId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getArtifact>>> = ({ signal }) => getArtifact(softwareModuleId,artifactId,params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(softwareModuleId && artifactId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getArtifact>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetArtifactQueryResult = NonNullable<Awaited<ReturnType<typeof getArtifact>>>
export type GetArtifactQueryError = ExceptionInfo


export function useGetArtifact<TData = Awaited<ReturnType<typeof getArtifact>>, TError = ExceptionInfo>(
 softwareModuleId: number,
    artifactId: number,
    params: undefined |  GetArtifactParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getArtifact>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getArtifact>>,
          TError,
          Awaited<ReturnType<typeof getArtifact>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetArtifact<TData = Awaited<ReturnType<typeof getArtifact>>, TError = ExceptionInfo>(
 softwareModuleId: number,
    artifactId: number,
    params?: GetArtifactParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getArtifact>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getArtifact>>,
          TError,
          Awaited<ReturnType<typeof getArtifact>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetArtifact<TData = Awaited<ReturnType<typeof getArtifact>>, TError = ExceptionInfo>(
 softwareModuleId: number,
    artifactId: number,
    params?: GetArtifactParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getArtifact>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Return single Artifact metadata
 */

export function useGetArtifact<TData = Awaited<ReturnType<typeof getArtifact>>, TError = ExceptionInfo>(
 softwareModuleId: number,
    artifactId: number,
    params?: GetArtifactParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getArtifact>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetArtifactQueryOptions(softwareModuleId,artifactId,params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Handles the DELETE request for a single Artifact assigned to a SoftwareModule. Required Permission: DELETE_REPOSITORY
 * @summary Delete artifact by Id
 */
export const deleteArtifact = (
    softwareModuleId: number,
    artifactId: number,
 options?: SecondParameter<typeof axiosInstance>,) => {
      
      
      return axiosInstance<void>(
      {url: `/rest/v1/softwaremodules/${softwareModuleId}/artifacts/${artifactId}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteArtifactMutationOptions = <TError = ExceptionInfo,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteArtifact>>, TError,{softwareModuleId: number;artifactId: number}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteArtifact>>, TError,{softwareModuleId: number;artifactId: number}, TContext> => {

const mutationKey = ['deleteArtifact'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteArtifact>>, {softwareModuleId: number;artifactId: number}> = (props) => {
          const {softwareModuleId,artifactId} = props ?? {};

          return  deleteArtifact(softwareModuleId,artifactId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteArtifactMutationResult = NonNullable<Awaited<ReturnType<typeof deleteArtifact>>>
    
    export type DeleteArtifactMutationError = ExceptionInfo

    /**
 * @summary Delete artifact by Id
 */
export const useDeleteArtifact = <TError = ExceptionInfo,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteArtifact>>, TError,{softwareModuleId: number;artifactId: number}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteArtifact>>,
        TError,
        {softwareModuleId: number;artifactId: number},
        TContext
      > => {

      const mutationOptions = getDeleteArtifactMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    