/**
 * Generated by orval v7.17.0 üç∫
 * Do not edit manually.
 * hawkBit REST APIs
 * Eclipse hawkBit‚Ñ¢ is a domain-independent back-end framework for rolling out software updates to constrained edge devices as well as more powerful controllers and gateways connected to IP based networking infrastructure.

 * OpenAPI spec version: v1
 */
import {
  useInfiniteQuery,
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseInfiniteQueryResult,
  DefinedUseQueryResult,
  InfiniteData,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  ApproveParams,
  DenyParams,
  ExceptionInfo,
  GetRolloutGroupTargetsParams,
  GetRolloutGroupsParams,
  GetRolloutsParams,
  MgmtRolloutGroupResponseBody,
  MgmtRolloutResponseBody,
  MgmtRolloutRestRequestBodyPost,
  MgmtRolloutRestRequestBodyPut,
  PagedListMgmtRolloutGroupResponseBody,
  PagedListMgmtRolloutResponseBody,
  PagedListMgmtTarget
} from '.././model';

import { axiosInstance } from '../../axios-instance';

// https://stackoverflow.com/questions/49579094/typescript-conditional-types-filter-out-readonly-properties-pick-only-requir/49579497#49579497
type IfEquals<X, Y, A = X, B = never> = (<T>() => T extends X ? 1 : 2) extends <
T,
>() => T extends Y ? 1 : 2
? A
: B;

type WritableKeys<T> = {
[P in keyof T]-?: IfEquals<
  { [Q in P]: T[P] },
  { -readonly [Q in P]: T[P] },
  P
>;
}[keyof T];

type UnionToIntersection<U> =
  (U extends any ? (k: U)=>void : never) extends ((k: infer I)=>void) ? I : never;
type DistributeReadOnlyOverUnions<T> = T extends any ? NonReadonly<T> : never;

type Writable<T> = Pick<T, WritableKeys<T>>;
type NonReadonly<T> = [T] extends [UnionToIntersection<T>] ? {
  [P in keyof Writable<T>]: T[P] extends object
    ? NonReadonly<NonNullable<T[P]>>
    : T[P];
} : DistributeReadOnlyOverUnions<T>;



type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * Handles the GET request of retrieving a single rollout. Required Permission: READ_ROLLOUT
 * @summary Return single Rollout
 */
export const getRollout = (
    rolloutId: number,
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      
      
      return axiosInstance<MgmtRolloutResponseBody>(
      {url: `/rest/v1/rollouts/${rolloutId}`, method: 'GET', signal
    },
      options);
    }
  



export const getGetRolloutInfiniteQueryKey = (rolloutId?: number,) => {
    return [
    'infinite', `/rest/v1/rollouts/${rolloutId}`
    ] as const;
    }

export const getGetRolloutQueryKey = (rolloutId?: number,) => {
    return [
    `/rest/v1/rollouts/${rolloutId}`
    ] as const;
    }

    
export const getGetRolloutInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getRollout>>>, TError = ExceptionInfo>(rolloutId: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRollout>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRolloutInfiniteQueryKey(rolloutId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRollout>>> = ({ signal }) => getRollout(rolloutId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(rolloutId), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRollout>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetRolloutInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getRollout>>>
export type GetRolloutInfiniteQueryError = ExceptionInfo


export function useGetRolloutInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRollout>>>, TError = ExceptionInfo>(
 rolloutId: number, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRollout>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRollout>>,
          TError,
          Awaited<ReturnType<typeof getRollout>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRolloutInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRollout>>>, TError = ExceptionInfo>(
 rolloutId: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRollout>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRollout>>,
          TError,
          Awaited<ReturnType<typeof getRollout>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRolloutInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRollout>>>, TError = ExceptionInfo>(
 rolloutId: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRollout>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Return single Rollout
 */

export function useGetRolloutInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRollout>>>, TError = ExceptionInfo>(
 rolloutId: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRollout>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetRolloutInfiniteQueryOptions(rolloutId,options)

  const query = useInfiniteQuery(queryOptions, queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getGetRolloutQueryOptions = <TData = Awaited<ReturnType<typeof getRollout>>, TError = ExceptionInfo>(rolloutId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRollout>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRolloutQueryKey(rolloutId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRollout>>> = ({ signal }) => getRollout(rolloutId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(rolloutId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getRollout>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetRolloutQueryResult = NonNullable<Awaited<ReturnType<typeof getRollout>>>
export type GetRolloutQueryError = ExceptionInfo


export function useGetRollout<TData = Awaited<ReturnType<typeof getRollout>>, TError = ExceptionInfo>(
 rolloutId: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRollout>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRollout>>,
          TError,
          Awaited<ReturnType<typeof getRollout>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRollout<TData = Awaited<ReturnType<typeof getRollout>>, TError = ExceptionInfo>(
 rolloutId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRollout>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRollout>>,
          TError,
          Awaited<ReturnType<typeof getRollout>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRollout<TData = Awaited<ReturnType<typeof getRollout>>, TError = ExceptionInfo>(
 rolloutId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRollout>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Return single Rollout
 */

export function useGetRollout<TData = Awaited<ReturnType<typeof getRollout>>, TError = ExceptionInfo>(
 rolloutId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRollout>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetRolloutQueryOptions(rolloutId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Handles the UPDATE request for a single Rollout. Required permission: UPDATE_ROLLOUT
 * @summary Update Rollout
 */
export const update = (
    rolloutId: number,
    mgmtRolloutRestRequestBodyPut: NonReadonly<MgmtRolloutRestRequestBodyPut>,
 options?: SecondParameter<typeof axiosInstance>,) => {
      
      
      return axiosInstance<MgmtRolloutResponseBody>(
      {url: `/rest/v1/rollouts/${rolloutId}`, method: 'PUT',
      headers: {'Content-Type': 'application/hal+json', },
      data: mgmtRolloutRestRequestBodyPut
    },
      options);
    }
  


export const getUpdateMutationOptions = <TError = ExceptionInfo,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof update>>, TError,{rolloutId: number;data: NonReadonly<MgmtRolloutRestRequestBodyPut>}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof update>>, TError,{rolloutId: number;data: NonReadonly<MgmtRolloutRestRequestBodyPut>}, TContext> => {

const mutationKey = ['update'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof update>>, {rolloutId: number;data: NonReadonly<MgmtRolloutRestRequestBodyPut>}> = (props) => {
          const {rolloutId,data} = props ?? {};

          return  update(rolloutId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateMutationResult = NonNullable<Awaited<ReturnType<typeof update>>>
    export type UpdateMutationBody = NonReadonly<MgmtRolloutRestRequestBodyPut>
    export type UpdateMutationError = ExceptionInfo

    /**
 * @summary Update Rollout
 */
export const useUpdate = <TError = ExceptionInfo,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof update>>, TError,{rolloutId: number;data: NonReadonly<MgmtRolloutRestRequestBodyPut>}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof update>>,
        TError,
        {rolloutId: number;data: NonReadonly<MgmtRolloutRestRequestBodyPut>},
        TContext
      > => {

      const mutationOptions = getUpdateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Handles the DELETE request of deleting a rollout. Required Permission: DELETE_ROLLOUT
 * @summary Delete a Rollout
 */
export const _delete = (
    rolloutId: number,
 options?: SecondParameter<typeof axiosInstance>,) => {
      
      
      return axiosInstance<void>(
      {url: `/rest/v1/rollouts/${rolloutId}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteMutationOptions = <TError = ExceptionInfo,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof _delete>>, TError,{rolloutId: number}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof _delete>>, TError,{rolloutId: number}, TContext> => {

const mutationKey = ['_delete'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof _delete>>, {rolloutId: number}> = (props) => {
          const {rolloutId} = props ?? {};

          return  _delete(rolloutId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type _DeleteMutationResult = NonNullable<Awaited<ReturnType<typeof _delete>>>
    
    export type _DeleteMutationError = ExceptionInfo

    /**
 * @summary Delete a Rollout
 */
export const useDelete = <TError = ExceptionInfo,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof _delete>>, TError,{rolloutId: number}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof _delete>>,
        TError,
        {rolloutId: number},
        TContext
      > => {

      const mutationOptions = getDeleteMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Handles the GET request of retrieving all rollouts. Required Permission: READ_ROLLOUT
 * @summary Return all Rollouts
 */
export const getRollouts = (
    params?: GetRolloutsParams,
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      
      
      return axiosInstance<PagedListMgmtRolloutResponseBody>(
      {url: `/rest/v1/rollouts`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getGetRolloutsInfiniteQueryKey = (params?: GetRolloutsParams,) => {
    return [
    'infinite', `/rest/v1/rollouts`, ...(params ? [params]: [])
    ] as const;
    }

export const getGetRolloutsQueryKey = (params?: GetRolloutsParams,) => {
    return [
    `/rest/v1/rollouts`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetRolloutsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getRollouts>>, GetRolloutsParams['offset']>, TError = ExceptionInfo>(params?: GetRolloutsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRollouts>>, TError, TData, QueryKey, GetRolloutsParams['offset']>>, request?: SecondParameter<typeof axiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRolloutsInfiniteQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRollouts>>, QueryKey, GetRolloutsParams['offset']> = ({ signal, pageParam }) => getRollouts({...params, 'offset': pageParam || params?.['offset']}, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRollouts>>, TError, TData, QueryKey, GetRolloutsParams['offset']> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetRolloutsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getRollouts>>>
export type GetRolloutsInfiniteQueryError = ExceptionInfo


export function useGetRolloutsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRollouts>>, GetRolloutsParams['offset']>, TError = ExceptionInfo>(
 params: undefined |  GetRolloutsParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRollouts>>, TError, TData, QueryKey, GetRolloutsParams['offset']>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRollouts>>,
          TError,
          Awaited<ReturnType<typeof getRollouts>>, QueryKey
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRolloutsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRollouts>>, GetRolloutsParams['offset']>, TError = ExceptionInfo>(
 params?: GetRolloutsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRollouts>>, TError, TData, QueryKey, GetRolloutsParams['offset']>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRollouts>>,
          TError,
          Awaited<ReturnType<typeof getRollouts>>, QueryKey
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRolloutsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRollouts>>, GetRolloutsParams['offset']>, TError = ExceptionInfo>(
 params?: GetRolloutsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRollouts>>, TError, TData, QueryKey, GetRolloutsParams['offset']>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Return all Rollouts
 */

export function useGetRolloutsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRollouts>>, GetRolloutsParams['offset']>, TError = ExceptionInfo>(
 params?: GetRolloutsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRollouts>>, TError, TData, QueryKey, GetRolloutsParams['offset']>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetRolloutsInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions, queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getGetRolloutsQueryOptions = <TData = Awaited<ReturnType<typeof getRollouts>>, TError = ExceptionInfo>(params?: GetRolloutsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRollouts>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRolloutsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRollouts>>> = ({ signal }) => getRollouts(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getRollouts>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetRolloutsQueryResult = NonNullable<Awaited<ReturnType<typeof getRollouts>>>
export type GetRolloutsQueryError = ExceptionInfo


export function useGetRollouts<TData = Awaited<ReturnType<typeof getRollouts>>, TError = ExceptionInfo>(
 params: undefined |  GetRolloutsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRollouts>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRollouts>>,
          TError,
          Awaited<ReturnType<typeof getRollouts>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRollouts<TData = Awaited<ReturnType<typeof getRollouts>>, TError = ExceptionInfo>(
 params?: GetRolloutsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRollouts>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRollouts>>,
          TError,
          Awaited<ReturnType<typeof getRollouts>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRollouts<TData = Awaited<ReturnType<typeof getRollouts>>, TError = ExceptionInfo>(
 params?: GetRolloutsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRollouts>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Return all Rollouts
 */

export function useGetRollouts<TData = Awaited<ReturnType<typeof getRollouts>>, TError = ExceptionInfo>(
 params?: GetRolloutsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRollouts>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetRolloutsQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Handles the POST request of creating new rollout. Required Permission: CREATE_ROLLOUT
 * @summary Create a new Rollout
 */
export const create = (
    mgmtRolloutRestRequestBodyPost: NonReadonly<MgmtRolloutRestRequestBodyPost>,
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      
      
      return axiosInstance<MgmtRolloutResponseBody>(
      {url: `/rest/v1/rollouts`, method: 'POST',
      headers: {'Content-Type': 'application/hal+json', },
      data: mgmtRolloutRestRequestBodyPost, signal
    },
      options);
    }
  


export const getCreateMutationOptions = <TError = ExceptionInfo,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof create>>, TError,{data: NonReadonly<MgmtRolloutRestRequestBodyPost>}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof create>>, TError,{data: NonReadonly<MgmtRolloutRestRequestBodyPost>}, TContext> => {

const mutationKey = ['create'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof create>>, {data: NonReadonly<MgmtRolloutRestRequestBodyPost>}> = (props) => {
          const {data} = props ?? {};

          return  create(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateMutationResult = NonNullable<Awaited<ReturnType<typeof create>>>
    export type CreateMutationBody = NonReadonly<MgmtRolloutRestRequestBodyPost>
    export type CreateMutationError = ExceptionInfo

    /**
 * @summary Create a new Rollout
 */
export const useCreate = <TError = ExceptionInfo,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof create>>, TError,{data: NonReadonly<MgmtRolloutRestRequestBodyPost>}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof create>>,
        TError,
        {data: NonReadonly<MgmtRolloutRestRequestBodyPost>},
        TContext
      > => {

      const mutationOptions = getCreateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Handles the POST request of triggering the next group of a rollout. Required Permission: UPDATE_ROLLOUT
 * @summary Force trigger processing next group of a Rollout
 */
export const triggerNextGroup = (
    rolloutId: number,
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      
      
      return axiosInstance<void>(
      {url: `/rest/v1/rollouts/${rolloutId}/triggerNextGroup`, method: 'POST', signal
    },
      options);
    }
  


export const getTriggerNextGroupMutationOptions = <TError = ExceptionInfo,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof triggerNextGroup>>, TError,{rolloutId: number}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof triggerNextGroup>>, TError,{rolloutId: number}, TContext> => {

const mutationKey = ['triggerNextGroup'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof triggerNextGroup>>, {rolloutId: number}> = (props) => {
          const {rolloutId} = props ?? {};

          return  triggerNextGroup(rolloutId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type TriggerNextGroupMutationResult = NonNullable<Awaited<ReturnType<typeof triggerNextGroup>>>
    
    export type TriggerNextGroupMutationError = ExceptionInfo

    /**
 * @summary Force trigger processing next group of a Rollout
 */
export const useTriggerNextGroup = <TError = ExceptionInfo,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof triggerNextGroup>>, TError,{rolloutId: number}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof triggerNextGroup>>,
        TError,
        {rolloutId: number},
        TContext
      > => {

      const mutationOptions = getTriggerNextGroupMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Handles the POST request of starting a created rollout. Required Permission: HANDLE_ROLLOUT
 * @summary Start a Rollout
 */
export const start = (
    rolloutId: number,
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      
      
      return axiosInstance<void>(
      {url: `/rest/v1/rollouts/${rolloutId}/start`, method: 'POST', signal
    },
      options);
    }
  


export const getStartMutationOptions = <TError = ExceptionInfo,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof start>>, TError,{rolloutId: number}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof start>>, TError,{rolloutId: number}, TContext> => {

const mutationKey = ['start'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof start>>, {rolloutId: number}> = (props) => {
          const {rolloutId} = props ?? {};

          return  start(rolloutId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type StartMutationResult = NonNullable<Awaited<ReturnType<typeof start>>>
    
    export type StartMutationError = ExceptionInfo

    /**
 * @summary Start a Rollout
 */
export const useStart = <TError = ExceptionInfo,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof start>>, TError,{rolloutId: number}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof start>>,
        TError,
        {rolloutId: number},
        TContext
      > => {

      const mutationOptions = getStartMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Handles the POST request of retrying a rollout. Required Permission: CREATE_ROLLOUT
 * @summary Retry a rollout
 */
export const retryRollout = (
    rolloutId: number,
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      
      
      return axiosInstance<MgmtRolloutResponseBody>(
      {url: `/rest/v1/rollouts/${rolloutId}/retry`, method: 'POST', signal
    },
      options);
    }
  


export const getRetryRolloutMutationOptions = <TError = ExceptionInfo,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof retryRollout>>, TError,{rolloutId: number}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof retryRollout>>, TError,{rolloutId: number}, TContext> => {

const mutationKey = ['retryRollout'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof retryRollout>>, {rolloutId: number}> = (props) => {
          const {rolloutId} = props ?? {};

          return  retryRollout(rolloutId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RetryRolloutMutationResult = NonNullable<Awaited<ReturnType<typeof retryRollout>>>
    
    export type RetryRolloutMutationError = ExceptionInfo

    /**
 * @summary Retry a rollout
 */
export const useRetryRollout = <TError = ExceptionInfo,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof retryRollout>>, TError,{rolloutId: number}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof retryRollout>>,
        TError,
        {rolloutId: number},
        TContext
      > => {

      const mutationOptions = getRetryRolloutMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Handles the POST request of resuming a paused rollout. Required Permission: HANDLE_ROLLOUT
 * @summary Resume a Rollout
 */
export const resume = (
    rolloutId: number,
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      
      
      return axiosInstance<void>(
      {url: `/rest/v1/rollouts/${rolloutId}/resume`, method: 'POST', signal
    },
      options);
    }
  


export const getResumeMutationOptions = <TError = ExceptionInfo,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof resume>>, TError,{rolloutId: number}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof resume>>, TError,{rolloutId: number}, TContext> => {

const mutationKey = ['resume'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof resume>>, {rolloutId: number}> = (props) => {
          const {rolloutId} = props ?? {};

          return  resume(rolloutId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ResumeMutationResult = NonNullable<Awaited<ReturnType<typeof resume>>>
    
    export type ResumeMutationError = ExceptionInfo

    /**
 * @summary Resume a Rollout
 */
export const useResume = <TError = ExceptionInfo,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof resume>>, TError,{rolloutId: number}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof resume>>,
        TError,
        {rolloutId: number},
        TContext
      > => {

      const mutationOptions = getResumeMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Handles the POST request of pausing a running rollout. Required Permission: HANDLE_ROLLOUT
 * @summary Pause a Rollout
 */
export const pause = (
    rolloutId: number,
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      
      
      return axiosInstance<void>(
      {url: `/rest/v1/rollouts/${rolloutId}/pause`, method: 'POST', signal
    },
      options);
    }
  


export const getPauseMutationOptions = <TError = ExceptionInfo,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof pause>>, TError,{rolloutId: number}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof pause>>, TError,{rolloutId: number}, TContext> => {

const mutationKey = ['pause'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof pause>>, {rolloutId: number}> = (props) => {
          const {rolloutId} = props ?? {};

          return  pause(rolloutId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PauseMutationResult = NonNullable<Awaited<ReturnType<typeof pause>>>
    
    export type PauseMutationError = ExceptionInfo

    /**
 * @summary Pause a Rollout
 */
export const usePause = <TError = ExceptionInfo,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof pause>>, TError,{rolloutId: number}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof pause>>,
        TError,
        {rolloutId: number},
        TContext
      > => {

      const mutationOptions = getPauseMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Handles the POST request of denying a created rollout. Only possible if approval workflow is enabled in system configuration and rollout is in state WAITING_FOR_APPROVAL. Required Permission: APPROVE_ROLLOUT
 * @summary Deny a Rollout
 */
export const deny = (
    rolloutId: number,
    params?: DenyParams,
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      
      
      return axiosInstance<void>(
      {url: `/rest/v1/rollouts/${rolloutId}/deny`, method: 'POST',
        params, signal
    },
      options);
    }
  


export const getDenyMutationOptions = <TError = ExceptionInfo,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deny>>, TError,{rolloutId: number;params?: DenyParams}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deny>>, TError,{rolloutId: number;params?: DenyParams}, TContext> => {

const mutationKey = ['deny'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deny>>, {rolloutId: number;params?: DenyParams}> = (props) => {
          const {rolloutId,params} = props ?? {};

          return  deny(rolloutId,params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DenyMutationResult = NonNullable<Awaited<ReturnType<typeof deny>>>
    
    export type DenyMutationError = ExceptionInfo

    /**
 * @summary Deny a Rollout
 */
export const useDeny = <TError = ExceptionInfo,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deny>>, TError,{rolloutId: number;params?: DenyParams}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deny>>,
        TError,
        {rolloutId: number;params?: DenyParams},
        TContext
      > => {

      const mutationOptions = getDenyMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Handles the POST request of approving a created rollout. Only possible if approval workflow is enabled in system configuration and rollout is in state WAITING_FOR_APPROVAL. Required Permission: APPROVE_ROLLOUT
 * @summary Approve a Rollout
 */
export const approve = (
    rolloutId: number,
    params?: ApproveParams,
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      
      
      return axiosInstance<void>(
      {url: `/rest/v1/rollouts/${rolloutId}/approve`, method: 'POST',
        params, signal
    },
      options);
    }
  


export const getApproveMutationOptions = <TError = ExceptionInfo,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof approve>>, TError,{rolloutId: number;params?: ApproveParams}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof approve>>, TError,{rolloutId: number;params?: ApproveParams}, TContext> => {

const mutationKey = ['approve'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof approve>>, {rolloutId: number;params?: ApproveParams}> = (props) => {
          const {rolloutId,params} = props ?? {};

          return  approve(rolloutId,params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApproveMutationResult = NonNullable<Awaited<ReturnType<typeof approve>>>
    
    export type ApproveMutationError = ExceptionInfo

    /**
 * @summary Approve a Rollout
 */
export const useApprove = <TError = ExceptionInfo,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof approve>>, TError,{rolloutId: number;params?: ApproveParams}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof approve>>,
        TError,
        {rolloutId: number;params?: ApproveParams},
        TContext
      > => {

      const mutationOptions = getApproveMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Handles the GET request of retrieving all deploy groups of a specific rollout. Required Permission: READ_ROLLOUT
 * @summary Return all rollout groups referred to a Rollout
 */
export const getRolloutGroups = (
    rolloutId: number,
    params?: GetRolloutGroupsParams,
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      
      
      return axiosInstance<PagedListMgmtRolloutGroupResponseBody>(
      {url: `/rest/v1/rollouts/${rolloutId}/deploygroups`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getGetRolloutGroupsInfiniteQueryKey = (rolloutId?: number,
    params?: GetRolloutGroupsParams,) => {
    return [
    'infinite', `/rest/v1/rollouts/${rolloutId}/deploygroups`, ...(params ? [params]: [])
    ] as const;
    }

export const getGetRolloutGroupsQueryKey = (rolloutId?: number,
    params?: GetRolloutGroupsParams,) => {
    return [
    `/rest/v1/rollouts/${rolloutId}/deploygroups`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetRolloutGroupsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getRolloutGroups>>, GetRolloutGroupsParams['offset']>, TError = ExceptionInfo>(rolloutId: number,
    params?: GetRolloutGroupsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRolloutGroups>>, TError, TData, QueryKey, GetRolloutGroupsParams['offset']>>, request?: SecondParameter<typeof axiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRolloutGroupsInfiniteQueryKey(rolloutId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRolloutGroups>>, QueryKey, GetRolloutGroupsParams['offset']> = ({ signal, pageParam }) => getRolloutGroups(rolloutId,{...params, 'offset': pageParam || params?.['offset']}, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(rolloutId), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRolloutGroups>>, TError, TData, QueryKey, GetRolloutGroupsParams['offset']> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetRolloutGroupsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getRolloutGroups>>>
export type GetRolloutGroupsInfiniteQueryError = ExceptionInfo


export function useGetRolloutGroupsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRolloutGroups>>, GetRolloutGroupsParams['offset']>, TError = ExceptionInfo>(
 rolloutId: number,
    params: undefined |  GetRolloutGroupsParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRolloutGroups>>, TError, TData, QueryKey, GetRolloutGroupsParams['offset']>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRolloutGroups>>,
          TError,
          Awaited<ReturnType<typeof getRolloutGroups>>, QueryKey
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRolloutGroupsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRolloutGroups>>, GetRolloutGroupsParams['offset']>, TError = ExceptionInfo>(
 rolloutId: number,
    params?: GetRolloutGroupsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRolloutGroups>>, TError, TData, QueryKey, GetRolloutGroupsParams['offset']>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRolloutGroups>>,
          TError,
          Awaited<ReturnType<typeof getRolloutGroups>>, QueryKey
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRolloutGroupsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRolloutGroups>>, GetRolloutGroupsParams['offset']>, TError = ExceptionInfo>(
 rolloutId: number,
    params?: GetRolloutGroupsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRolloutGroups>>, TError, TData, QueryKey, GetRolloutGroupsParams['offset']>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Return all rollout groups referred to a Rollout
 */

export function useGetRolloutGroupsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRolloutGroups>>, GetRolloutGroupsParams['offset']>, TError = ExceptionInfo>(
 rolloutId: number,
    params?: GetRolloutGroupsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRolloutGroups>>, TError, TData, QueryKey, GetRolloutGroupsParams['offset']>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetRolloutGroupsInfiniteQueryOptions(rolloutId,params,options)

  const query = useInfiniteQuery(queryOptions, queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getGetRolloutGroupsQueryOptions = <TData = Awaited<ReturnType<typeof getRolloutGroups>>, TError = ExceptionInfo>(rolloutId: number,
    params?: GetRolloutGroupsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRolloutGroups>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRolloutGroupsQueryKey(rolloutId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRolloutGroups>>> = ({ signal }) => getRolloutGroups(rolloutId,params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(rolloutId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getRolloutGroups>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetRolloutGroupsQueryResult = NonNullable<Awaited<ReturnType<typeof getRolloutGroups>>>
export type GetRolloutGroupsQueryError = ExceptionInfo


export function useGetRolloutGroups<TData = Awaited<ReturnType<typeof getRolloutGroups>>, TError = ExceptionInfo>(
 rolloutId: number,
    params: undefined |  GetRolloutGroupsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRolloutGroups>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRolloutGroups>>,
          TError,
          Awaited<ReturnType<typeof getRolloutGroups>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRolloutGroups<TData = Awaited<ReturnType<typeof getRolloutGroups>>, TError = ExceptionInfo>(
 rolloutId: number,
    params?: GetRolloutGroupsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRolloutGroups>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRolloutGroups>>,
          TError,
          Awaited<ReturnType<typeof getRolloutGroups>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRolloutGroups<TData = Awaited<ReturnType<typeof getRolloutGroups>>, TError = ExceptionInfo>(
 rolloutId: number,
    params?: GetRolloutGroupsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRolloutGroups>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Return all rollout groups referred to a Rollout
 */

export function useGetRolloutGroups<TData = Awaited<ReturnType<typeof getRolloutGroups>>, TError = ExceptionInfo>(
 rolloutId: number,
    params?: GetRolloutGroupsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRolloutGroups>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetRolloutGroupsQueryOptions(rolloutId,params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Handles the GET request of a single deploy group of a specific rollout. Required Permission: READ_ROLLOUT
 * @summary Return single rollout group
 */
export const getRolloutGroup = (
    rolloutId: number,
    groupId: number,
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      
      
      return axiosInstance<MgmtRolloutGroupResponseBody>(
      {url: `/rest/v1/rollouts/${rolloutId}/deploygroups/${groupId}`, method: 'GET', signal
    },
      options);
    }
  



export const getGetRolloutGroupInfiniteQueryKey = (rolloutId?: number,
    groupId?: number,) => {
    return [
    'infinite', `/rest/v1/rollouts/${rolloutId}/deploygroups/${groupId}`
    ] as const;
    }

export const getGetRolloutGroupQueryKey = (rolloutId?: number,
    groupId?: number,) => {
    return [
    `/rest/v1/rollouts/${rolloutId}/deploygroups/${groupId}`
    ] as const;
    }

    
export const getGetRolloutGroupInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getRolloutGroup>>>, TError = ExceptionInfo>(rolloutId: number,
    groupId: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRolloutGroup>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRolloutGroupInfiniteQueryKey(rolloutId,groupId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRolloutGroup>>> = ({ signal }) => getRolloutGroup(rolloutId,groupId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(rolloutId && groupId), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRolloutGroup>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetRolloutGroupInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getRolloutGroup>>>
export type GetRolloutGroupInfiniteQueryError = ExceptionInfo


export function useGetRolloutGroupInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRolloutGroup>>>, TError = ExceptionInfo>(
 rolloutId: number,
    groupId: number, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRolloutGroup>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRolloutGroup>>,
          TError,
          Awaited<ReturnType<typeof getRolloutGroup>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRolloutGroupInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRolloutGroup>>>, TError = ExceptionInfo>(
 rolloutId: number,
    groupId: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRolloutGroup>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRolloutGroup>>,
          TError,
          Awaited<ReturnType<typeof getRolloutGroup>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRolloutGroupInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRolloutGroup>>>, TError = ExceptionInfo>(
 rolloutId: number,
    groupId: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRolloutGroup>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Return single rollout group
 */

export function useGetRolloutGroupInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRolloutGroup>>>, TError = ExceptionInfo>(
 rolloutId: number,
    groupId: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRolloutGroup>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetRolloutGroupInfiniteQueryOptions(rolloutId,groupId,options)

  const query = useInfiniteQuery(queryOptions, queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getGetRolloutGroupQueryOptions = <TData = Awaited<ReturnType<typeof getRolloutGroup>>, TError = ExceptionInfo>(rolloutId: number,
    groupId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRolloutGroup>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRolloutGroupQueryKey(rolloutId,groupId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRolloutGroup>>> = ({ signal }) => getRolloutGroup(rolloutId,groupId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(rolloutId && groupId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getRolloutGroup>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetRolloutGroupQueryResult = NonNullable<Awaited<ReturnType<typeof getRolloutGroup>>>
export type GetRolloutGroupQueryError = ExceptionInfo


export function useGetRolloutGroup<TData = Awaited<ReturnType<typeof getRolloutGroup>>, TError = ExceptionInfo>(
 rolloutId: number,
    groupId: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRolloutGroup>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRolloutGroup>>,
          TError,
          Awaited<ReturnType<typeof getRolloutGroup>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRolloutGroup<TData = Awaited<ReturnType<typeof getRolloutGroup>>, TError = ExceptionInfo>(
 rolloutId: number,
    groupId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRolloutGroup>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRolloutGroup>>,
          TError,
          Awaited<ReturnType<typeof getRolloutGroup>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRolloutGroup<TData = Awaited<ReturnType<typeof getRolloutGroup>>, TError = ExceptionInfo>(
 rolloutId: number,
    groupId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRolloutGroup>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Return single rollout group
 */

export function useGetRolloutGroup<TData = Awaited<ReturnType<typeof getRolloutGroup>>, TError = ExceptionInfo>(
 rolloutId: number,
    groupId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRolloutGroup>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetRolloutGroupQueryOptions(rolloutId,groupId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Handles the GET request of retrieving all targets of a single deploy group of a specific rollout. Required Permissions: READ_ROLLOUT, READ_TARGET.
 * @summary Return all targets related to a specific rollout group
 */
export const getRolloutGroupTargets = (
    rolloutId: number,
    groupId: number,
    params?: GetRolloutGroupTargetsParams,
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      
      
      return axiosInstance<PagedListMgmtTarget>(
      {url: `/rest/v1/rollouts/${rolloutId}/deploygroups/${groupId}/targets`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getGetRolloutGroupTargetsInfiniteQueryKey = (rolloutId?: number,
    groupId?: number,
    params?: GetRolloutGroupTargetsParams,) => {
    return [
    'infinite', `/rest/v1/rollouts/${rolloutId}/deploygroups/${groupId}/targets`, ...(params ? [params]: [])
    ] as const;
    }

export const getGetRolloutGroupTargetsQueryKey = (rolloutId?: number,
    groupId?: number,
    params?: GetRolloutGroupTargetsParams,) => {
    return [
    `/rest/v1/rollouts/${rolloutId}/deploygroups/${groupId}/targets`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetRolloutGroupTargetsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getRolloutGroupTargets>>, GetRolloutGroupTargetsParams['offset']>, TError = ExceptionInfo>(rolloutId: number,
    groupId: number,
    params?: GetRolloutGroupTargetsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRolloutGroupTargets>>, TError, TData, QueryKey, GetRolloutGroupTargetsParams['offset']>>, request?: SecondParameter<typeof axiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRolloutGroupTargetsInfiniteQueryKey(rolloutId,groupId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRolloutGroupTargets>>, QueryKey, GetRolloutGroupTargetsParams['offset']> = ({ signal, pageParam }) => getRolloutGroupTargets(rolloutId,groupId,{...params, 'offset': pageParam || params?.['offset']}, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(rolloutId && groupId), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRolloutGroupTargets>>, TError, TData, QueryKey, GetRolloutGroupTargetsParams['offset']> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetRolloutGroupTargetsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getRolloutGroupTargets>>>
export type GetRolloutGroupTargetsInfiniteQueryError = ExceptionInfo


export function useGetRolloutGroupTargetsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRolloutGroupTargets>>, GetRolloutGroupTargetsParams['offset']>, TError = ExceptionInfo>(
 rolloutId: number,
    groupId: number,
    params: undefined |  GetRolloutGroupTargetsParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRolloutGroupTargets>>, TError, TData, QueryKey, GetRolloutGroupTargetsParams['offset']>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRolloutGroupTargets>>,
          TError,
          Awaited<ReturnType<typeof getRolloutGroupTargets>>, QueryKey
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRolloutGroupTargetsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRolloutGroupTargets>>, GetRolloutGroupTargetsParams['offset']>, TError = ExceptionInfo>(
 rolloutId: number,
    groupId: number,
    params?: GetRolloutGroupTargetsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRolloutGroupTargets>>, TError, TData, QueryKey, GetRolloutGroupTargetsParams['offset']>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRolloutGroupTargets>>,
          TError,
          Awaited<ReturnType<typeof getRolloutGroupTargets>>, QueryKey
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRolloutGroupTargetsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRolloutGroupTargets>>, GetRolloutGroupTargetsParams['offset']>, TError = ExceptionInfo>(
 rolloutId: number,
    groupId: number,
    params?: GetRolloutGroupTargetsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRolloutGroupTargets>>, TError, TData, QueryKey, GetRolloutGroupTargetsParams['offset']>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Return all targets related to a specific rollout group
 */

export function useGetRolloutGroupTargetsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRolloutGroupTargets>>, GetRolloutGroupTargetsParams['offset']>, TError = ExceptionInfo>(
 rolloutId: number,
    groupId: number,
    params?: GetRolloutGroupTargetsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getRolloutGroupTargets>>, TError, TData, QueryKey, GetRolloutGroupTargetsParams['offset']>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetRolloutGroupTargetsInfiniteQueryOptions(rolloutId,groupId,params,options)

  const query = useInfiniteQuery(queryOptions, queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getGetRolloutGroupTargetsQueryOptions = <TData = Awaited<ReturnType<typeof getRolloutGroupTargets>>, TError = ExceptionInfo>(rolloutId: number,
    groupId: number,
    params?: GetRolloutGroupTargetsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRolloutGroupTargets>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRolloutGroupTargetsQueryKey(rolloutId,groupId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRolloutGroupTargets>>> = ({ signal }) => getRolloutGroupTargets(rolloutId,groupId,params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(rolloutId && groupId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getRolloutGroupTargets>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetRolloutGroupTargetsQueryResult = NonNullable<Awaited<ReturnType<typeof getRolloutGroupTargets>>>
export type GetRolloutGroupTargetsQueryError = ExceptionInfo


export function useGetRolloutGroupTargets<TData = Awaited<ReturnType<typeof getRolloutGroupTargets>>, TError = ExceptionInfo>(
 rolloutId: number,
    groupId: number,
    params: undefined |  GetRolloutGroupTargetsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRolloutGroupTargets>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRolloutGroupTargets>>,
          TError,
          Awaited<ReturnType<typeof getRolloutGroupTargets>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRolloutGroupTargets<TData = Awaited<ReturnType<typeof getRolloutGroupTargets>>, TError = ExceptionInfo>(
 rolloutId: number,
    groupId: number,
    params?: GetRolloutGroupTargetsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRolloutGroupTargets>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRolloutGroupTargets>>,
          TError,
          Awaited<ReturnType<typeof getRolloutGroupTargets>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRolloutGroupTargets<TData = Awaited<ReturnType<typeof getRolloutGroupTargets>>, TError = ExceptionInfo>(
 rolloutId: number,
    groupId: number,
    params?: GetRolloutGroupTargetsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRolloutGroupTargets>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Return all targets related to a specific rollout group
 */

export function useGetRolloutGroupTargets<TData = Awaited<ReturnType<typeof getRolloutGroupTargets>>, TError = ExceptionInfo>(
 rolloutId: number,
    groupId: number,
    params?: GetRolloutGroupTargetsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRolloutGroupTargets>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetRolloutGroupTargetsQueryOptions(rolloutId,groupId,params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




