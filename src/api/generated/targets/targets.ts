/**
 * Generated by orval v7.17.0 üç∫
 * Do not edit manually.
 * hawkBit REST APIs
 * Eclipse hawkBit‚Ñ¢ is a domain-independent back-end framework for rolling out software updates to constrained edge devices as well as more powerful controllers and gateways connected to IP based networking infrastructure.

 * OpenAPI spec version: v1
 */
import {
  useInfiniteQuery,
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseInfiniteQueryResult,
  DefinedUseQueryResult,
  InfiniteData,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  CancelActionParams,
  ExceptionInfo,
  GetActionHistoryParams,
  GetActionStatusListParams,
  GetMetadataParams,
  GetTargetsParams,
  MgmtAction,
  MgmtActionConfirmationRequestBodyPut,
  MgmtActionRequestBodyPut,
  MgmtDistributionSet,
  MgmtDistributionSetAssignments,
  MgmtId,
  MgmtMetadata,
  MgmtMetadataBodyPut,
  MgmtTag,
  MgmtTarget,
  MgmtTargetAssignmentResponseBody,
  MgmtTargetAttributes,
  MgmtTargetAutoConfirm,
  MgmtTargetAutoConfirmUpdate,
  MgmtTargetRequestBody,
  PagedListMgmtAction,
  PagedListMgmtActionStatus,
  PagedListMgmtMetadata,
  PagedListMgmtTarget,
  PostAssignedDistributionSetParams
} from '.././model';

import { axiosInstance } from '../../axios-instance';


type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * Handles the GET request of retrieving a single target. Required Permission: READ_TARGET.
 * @summary Return target by id
 */
export const getTarget = (
    targetId: string,
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      
      
      return axiosInstance<MgmtTarget>(
      {url: `/rest/v1/targets/${targetId}`, method: 'GET', signal
    },
      options);
    }
  



export const getGetTargetInfiniteQueryKey = (targetId?: string,) => {
    return [
    'infinite', `/rest/v1/targets/${targetId}`
    ] as const;
    }

export const getGetTargetQueryKey = (targetId?: string,) => {
    return [
    `/rest/v1/targets/${targetId}`
    ] as const;
    }

    
export const getGetTargetInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getTarget>>>, TError = ExceptionInfo>(targetId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTarget>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTargetInfiniteQueryKey(targetId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTarget>>> = ({ signal }) => getTarget(targetId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(targetId), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTarget>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetTargetInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getTarget>>>
export type GetTargetInfiniteQueryError = ExceptionInfo


export function useGetTargetInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getTarget>>>, TError = ExceptionInfo>(
 targetId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTarget>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTarget>>,
          TError,
          Awaited<ReturnType<typeof getTarget>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTargetInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getTarget>>>, TError = ExceptionInfo>(
 targetId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTarget>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTarget>>,
          TError,
          Awaited<ReturnType<typeof getTarget>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTargetInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getTarget>>>, TError = ExceptionInfo>(
 targetId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTarget>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Return target by id
 */

export function useGetTargetInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getTarget>>>, TError = ExceptionInfo>(
 targetId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTarget>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetTargetInfiniteQueryOptions(targetId,options)

  const query = useInfiniteQuery(queryOptions, queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getGetTargetQueryOptions = <TData = Awaited<ReturnType<typeof getTarget>>, TError = ExceptionInfo>(targetId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTarget>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTargetQueryKey(targetId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTarget>>> = ({ signal }) => getTarget(targetId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(targetId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getTarget>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetTargetQueryResult = NonNullable<Awaited<ReturnType<typeof getTarget>>>
export type GetTargetQueryError = ExceptionInfo


export function useGetTarget<TData = Awaited<ReturnType<typeof getTarget>>, TError = ExceptionInfo>(
 targetId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTarget>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTarget>>,
          TError,
          Awaited<ReturnType<typeof getTarget>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTarget<TData = Awaited<ReturnType<typeof getTarget>>, TError = ExceptionInfo>(
 targetId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTarget>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTarget>>,
          TError,
          Awaited<ReturnType<typeof getTarget>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTarget<TData = Awaited<ReturnType<typeof getTarget>>, TError = ExceptionInfo>(
 targetId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTarget>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Return target by id
 */

export function useGetTarget<TData = Awaited<ReturnType<typeof getTarget>>, TError = ExceptionInfo>(
 targetId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTarget>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetTargetQueryOptions(targetId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Handles the PUT request of updating a target. Required Permission: UPDATE_TARGET
 * @summary Update target by id
 */
export const updateTarget = (
    targetId: string,
    mgmtTargetRequestBody: MgmtTargetRequestBody,
 options?: SecondParameter<typeof axiosInstance>,) => {
      
      
      return axiosInstance<MgmtTarget>(
      {url: `/rest/v1/targets/${targetId}`, method: 'PUT',
      headers: {'Content-Type': 'application/hal+json', },
      data: mgmtTargetRequestBody
    },
      options);
    }
  


export const getUpdateTargetMutationOptions = <TError = ExceptionInfo,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateTarget>>, TError,{targetId: string;data: MgmtTargetRequestBody}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updateTarget>>, TError,{targetId: string;data: MgmtTargetRequestBody}, TContext> => {

const mutationKey = ['updateTarget'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateTarget>>, {targetId: string;data: MgmtTargetRequestBody}> = (props) => {
          const {targetId,data} = props ?? {};

          return  updateTarget(targetId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateTargetMutationResult = NonNullable<Awaited<ReturnType<typeof updateTarget>>>
    export type UpdateTargetMutationBody = MgmtTargetRequestBody
    export type UpdateTargetMutationError = ExceptionInfo

    /**
 * @summary Update target by id
 */
export const useUpdateTarget = <TError = ExceptionInfo,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateTarget>>, TError,{targetId: string;data: MgmtTargetRequestBody}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateTarget>>,
        TError,
        {targetId: string;data: MgmtTargetRequestBody},
        TContext
      > => {

      const mutationOptions = getUpdateTargetMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Handles the DELETE request of deleting a single target. Required Permission: DELETE_TARGET
 * @summary Delete target by id
 */
export const deleteTarget = (
    targetId: string,
 options?: SecondParameter<typeof axiosInstance>,) => {
      
      
      return axiosInstance<void>(
      {url: `/rest/v1/targets/${targetId}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteTargetMutationOptions = <TError = ExceptionInfo,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteTarget>>, TError,{targetId: string}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteTarget>>, TError,{targetId: string}, TContext> => {

const mutationKey = ['deleteTarget'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteTarget>>, {targetId: string}> = (props) => {
          const {targetId} = props ?? {};

          return  deleteTarget(targetId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteTargetMutationResult = NonNullable<Awaited<ReturnType<typeof deleteTarget>>>
    
    export type DeleteTargetMutationError = ExceptionInfo

    /**
 * @summary Delete target by id
 */
export const useDeleteTarget = <TError = ExceptionInfo,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteTarget>>, TError,{targetId: string}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteTarget>>,
        TError,
        {targetId: string},
        TContext
      > => {

      const mutationOptions = getDeleteTargetMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Get a single metadata value for a metadata key. Required permission: READ_REPOSITORY
 * @summary Return single metadata value for a specific key of a target
 */
export const getMetadataValue = (
    targetId: string,
    metadataKey: string,
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      
      
      return axiosInstance<MgmtMetadata>(
      {url: `/rest/v1/targets/${targetId}/metadata/${metadataKey}`, method: 'GET', signal
    },
      options);
    }
  



export const getGetMetadataValueInfiniteQueryKey = (targetId?: string,
    metadataKey?: string,) => {
    return [
    'infinite', `/rest/v1/targets/${targetId}/metadata/${metadataKey}`
    ] as const;
    }

export const getGetMetadataValueQueryKey = (targetId?: string,
    metadataKey?: string,) => {
    return [
    `/rest/v1/targets/${targetId}/metadata/${metadataKey}`
    ] as const;
    }

    
export const getGetMetadataValueInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getMetadataValue>>>, TError = ExceptionInfo>(targetId: string,
    metadataKey: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMetadataValue>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMetadataValueInfiniteQueryKey(targetId,metadataKey);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMetadataValue>>> = ({ signal }) => getMetadataValue(targetId,metadataKey, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(targetId && metadataKey), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMetadataValue>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetMetadataValueInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getMetadataValue>>>
export type GetMetadataValueInfiniteQueryError = ExceptionInfo


export function useGetMetadataValueInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getMetadataValue>>>, TError = ExceptionInfo>(
 targetId: string,
    metadataKey: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMetadataValue>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMetadataValue>>,
          TError,
          Awaited<ReturnType<typeof getMetadataValue>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetMetadataValueInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getMetadataValue>>>, TError = ExceptionInfo>(
 targetId: string,
    metadataKey: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMetadataValue>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMetadataValue>>,
          TError,
          Awaited<ReturnType<typeof getMetadataValue>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetMetadataValueInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getMetadataValue>>>, TError = ExceptionInfo>(
 targetId: string,
    metadataKey: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMetadataValue>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Return single metadata value for a specific key of a target
 */

export function useGetMetadataValueInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getMetadataValue>>>, TError = ExceptionInfo>(
 targetId: string,
    metadataKey: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMetadataValue>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetMetadataValueInfiniteQueryOptions(targetId,metadataKey,options)

  const query = useInfiniteQuery(queryOptions, queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getGetMetadataValueQueryOptions = <TData = Awaited<ReturnType<typeof getMetadataValue>>, TError = ExceptionInfo>(targetId: string,
    metadataKey: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMetadataValue>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMetadataValueQueryKey(targetId,metadataKey);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMetadataValue>>> = ({ signal }) => getMetadataValue(targetId,metadataKey, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(targetId && metadataKey), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMetadataValue>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetMetadataValueQueryResult = NonNullable<Awaited<ReturnType<typeof getMetadataValue>>>
export type GetMetadataValueQueryError = ExceptionInfo


export function useGetMetadataValue<TData = Awaited<ReturnType<typeof getMetadataValue>>, TError = ExceptionInfo>(
 targetId: string,
    metadataKey: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMetadataValue>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMetadataValue>>,
          TError,
          Awaited<ReturnType<typeof getMetadataValue>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetMetadataValue<TData = Awaited<ReturnType<typeof getMetadataValue>>, TError = ExceptionInfo>(
 targetId: string,
    metadataKey: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMetadataValue>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMetadataValue>>,
          TError,
          Awaited<ReturnType<typeof getMetadataValue>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetMetadataValue<TData = Awaited<ReturnType<typeof getMetadataValue>>, TError = ExceptionInfo>(
 targetId: string,
    metadataKey: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMetadataValue>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Return single metadata value for a specific key of a target
 */

export function useGetMetadataValue<TData = Awaited<ReturnType<typeof getMetadataValue>>, TError = ExceptionInfo>(
 targetId: string,
    metadataKey: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMetadataValue>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetMetadataValueQueryOptions(targetId,metadataKey,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update a single metadata value for speficic key. Required permission: UPDATE_REPOSITORY
 * @summary Updates a single metadata value of a target
 */
export const updateMetadata = (
    targetId: string,
    metadataKey: string,
    mgmtMetadataBodyPut: MgmtMetadataBodyPut,
 options?: SecondParameter<typeof axiosInstance>,) => {
      
      
      return axiosInstance<MgmtMetadata>(
      {url: `/rest/v1/targets/${targetId}/metadata/${metadataKey}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: mgmtMetadataBodyPut
    },
      options);
    }
  


export const getUpdateMetadataMutationOptions = <TError = ExceptionInfo,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateMetadata>>, TError,{targetId: string;metadataKey: string;data: MgmtMetadataBodyPut}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updateMetadata>>, TError,{targetId: string;metadataKey: string;data: MgmtMetadataBodyPut}, TContext> => {

const mutationKey = ['updateMetadata'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateMetadata>>, {targetId: string;metadataKey: string;data: MgmtMetadataBodyPut}> = (props) => {
          const {targetId,metadataKey,data} = props ?? {};

          return  updateMetadata(targetId,metadataKey,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateMetadataMutationResult = NonNullable<Awaited<ReturnType<typeof updateMetadata>>>
    export type UpdateMetadataMutationBody = MgmtMetadataBodyPut
    export type UpdateMetadataMutationError = ExceptionInfo

    /**
 * @summary Updates a single metadata value of a target
 */
export const useUpdateMetadata = <TError = ExceptionInfo,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateMetadata>>, TError,{targetId: string;metadataKey: string;data: MgmtMetadataBodyPut}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateMetadata>>,
        TError,
        {targetId: string;metadataKey: string;data: MgmtMetadataBodyPut},
        TContext
      > => {

      const mutationOptions = getUpdateMetadataMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Delete a single metadata. Required permission: UPDATE_REPOSITORY
 * @summary Deletes a single metadata entry from a target
 */
export const deleteMetadata = (
    targetId: string,
    metadataKey: string,
 options?: SecondParameter<typeof axiosInstance>,) => {
      
      
      return axiosInstance<void>(
      {url: `/rest/v1/targets/${targetId}/metadata/${metadataKey}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteMetadataMutationOptions = <TError = ExceptionInfo,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteMetadata>>, TError,{targetId: string;metadataKey: string}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteMetadata>>, TError,{targetId: string;metadataKey: string}, TContext> => {

const mutationKey = ['deleteMetadata'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteMetadata>>, {targetId: string;metadataKey: string}> = (props) => {
          const {targetId,metadataKey} = props ?? {};

          return  deleteMetadata(targetId,metadataKey,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteMetadataMutationResult = NonNullable<Awaited<ReturnType<typeof deleteMetadata>>>
    
    export type DeleteMetadataMutationError = ExceptionInfo

    /**
 * @summary Deletes a single metadata entry from a target
 */
export const useDeleteMetadata = <TError = ExceptionInfo,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteMetadata>>, TError,{targetId: string;metadataKey: string}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteMetadata>>,
        TError,
        {targetId: string;metadataKey: string},
        TContext
      > => {

      const mutationOptions = getDeleteMetadataMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Handles the GET request of retrieving a specific action on a specific target. Required Permission: READ_TARGET
 * @summary Return action by id of a specific target
 */
export const getAction = (
    targetId: string,
    actionId: number,
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      
      
      return axiosInstance<MgmtAction>(
      {url: `/rest/v1/targets/${targetId}/actions/${actionId}`, method: 'GET', signal
    },
      options);
    }
  



export const getGetActionInfiniteQueryKey = (targetId?: string,
    actionId?: number,) => {
    return [
    'infinite', `/rest/v1/targets/${targetId}/actions/${actionId}`
    ] as const;
    }

export const getGetActionQueryKey = (targetId?: string,
    actionId?: number,) => {
    return [
    `/rest/v1/targets/${targetId}/actions/${actionId}`
    ] as const;
    }

    
export const getGetActionInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getAction>>>, TError = ExceptionInfo>(targetId: string,
    actionId: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAction>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetActionInfiniteQueryKey(targetId,actionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAction>>> = ({ signal }) => getAction(targetId,actionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(targetId && actionId), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAction>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetActionInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAction>>>
export type GetActionInfiniteQueryError = ExceptionInfo


export function useGetActionInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAction>>>, TError = ExceptionInfo>(
 targetId: string,
    actionId: number, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAction>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAction>>,
          TError,
          Awaited<ReturnType<typeof getAction>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetActionInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAction>>>, TError = ExceptionInfo>(
 targetId: string,
    actionId: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAction>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAction>>,
          TError,
          Awaited<ReturnType<typeof getAction>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetActionInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAction>>>, TError = ExceptionInfo>(
 targetId: string,
    actionId: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAction>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Return action by id of a specific target
 */

export function useGetActionInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAction>>>, TError = ExceptionInfo>(
 targetId: string,
    actionId: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAction>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetActionInfiniteQueryOptions(targetId,actionId,options)

  const query = useInfiniteQuery(queryOptions, queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getGetActionQueryOptions = <TData = Awaited<ReturnType<typeof getAction>>, TError = ExceptionInfo>(targetId: string,
    actionId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAction>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetActionQueryKey(targetId,actionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAction>>> = ({ signal }) => getAction(targetId,actionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(targetId && actionId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAction>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetActionQueryResult = NonNullable<Awaited<ReturnType<typeof getAction>>>
export type GetActionQueryError = ExceptionInfo


export function useGetAction<TData = Awaited<ReturnType<typeof getAction>>, TError = ExceptionInfo>(
 targetId: string,
    actionId: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAction>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAction>>,
          TError,
          Awaited<ReturnType<typeof getAction>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAction<TData = Awaited<ReturnType<typeof getAction>>, TError = ExceptionInfo>(
 targetId: string,
    actionId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAction>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAction>>,
          TError,
          Awaited<ReturnType<typeof getAction>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAction<TData = Awaited<ReturnType<typeof getAction>>, TError = ExceptionInfo>(
 targetId: string,
    actionId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAction>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Return action by id of a specific target
 */

export function useGetAction<TData = Awaited<ReturnType<typeof getAction>>, TError = ExceptionInfo>(
 targetId: string,
    actionId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAction>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetActionQueryOptions(targetId,actionId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Handles the PUT request to switch an action from soft to forced. Required Permission: UPDATE_TARGET.
 * @summary Switch an action from soft to forced
 */
export const updateAction = (
    targetId: string,
    actionId: number,
    mgmtActionRequestBodyPut: MgmtActionRequestBodyPut,
 options?: SecondParameter<typeof axiosInstance>,) => {
      
      
      return axiosInstance<MgmtAction>(
      {url: `/rest/v1/targets/${targetId}/actions/${actionId}`, method: 'PUT',
      headers: {'Content-Type': 'application/hal+json', },
      data: mgmtActionRequestBodyPut
    },
      options);
    }
  


export const getUpdateActionMutationOptions = <TError = ExceptionInfo,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateAction>>, TError,{targetId: string;actionId: number;data: MgmtActionRequestBodyPut}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updateAction>>, TError,{targetId: string;actionId: number;data: MgmtActionRequestBodyPut}, TContext> => {

const mutationKey = ['updateAction'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateAction>>, {targetId: string;actionId: number;data: MgmtActionRequestBodyPut}> = (props) => {
          const {targetId,actionId,data} = props ?? {};

          return  updateAction(targetId,actionId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateActionMutationResult = NonNullable<Awaited<ReturnType<typeof updateAction>>>
    export type UpdateActionMutationBody = MgmtActionRequestBodyPut
    export type UpdateActionMutationError = ExceptionInfo

    /**
 * @summary Switch an action from soft to forced
 */
export const useUpdateAction = <TError = ExceptionInfo,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateAction>>, TError,{targetId: string;actionId: number;data: MgmtActionRequestBodyPut}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateAction>>,
        TError,
        {targetId: string;actionId: number;data: MgmtActionRequestBodyPut},
        TContext
      > => {

      const mutationOptions = getUpdateActionMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Cancels an active action, only active actions can be deleted. Required Permission: UPDATE_TARGET
 * @summary Cancel action for a specific target
 */
export const cancelAction = (
    targetId: string,
    actionId: number,
    params?: CancelActionParams,
 options?: SecondParameter<typeof axiosInstance>,) => {
      
      
      return axiosInstance<void>(
      {url: `/rest/v1/targets/${targetId}/actions/${actionId}`, method: 'DELETE',
        params
    },
      options);
    }
  


export const getCancelActionMutationOptions = <TError = ExceptionInfo,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof cancelAction>>, TError,{targetId: string;actionId: number;params?: CancelActionParams}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof cancelAction>>, TError,{targetId: string;actionId: number;params?: CancelActionParams}, TContext> => {

const mutationKey = ['cancelAction'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof cancelAction>>, {targetId: string;actionId: number;params?: CancelActionParams}> = (props) => {
          const {targetId,actionId,params} = props ?? {};

          return  cancelAction(targetId,actionId,params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CancelActionMutationResult = NonNullable<Awaited<ReturnType<typeof cancelAction>>>
    
    export type CancelActionMutationError = ExceptionInfo

    /**
 * @summary Cancel action for a specific target
 */
export const useCancelAction = <TError = ExceptionInfo,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof cancelAction>>, TError,{targetId: string;actionId: number;params?: CancelActionParams}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof cancelAction>>,
        TError,
        {targetId: string;actionId: number;params?: CancelActionParams},
        TContext
      > => {

      const mutationOptions = getCancelActionMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Either confirm or deny an action which is waiting for confirmation.
The action will be transferred into the RUNNING state in case confirming it.
The action will remain in WAITING_FOR_CONFIRMATION state in case denying it.
Required Permission: READ_REPOSITORY AND UPDATE_TARGET

 * @summary Controls (confirm/deny) actions waiting for confirmation
 */
export const updateActionConfirmation = (
    targetId: string,
    actionId: number,
    mgmtActionConfirmationRequestBodyPut: MgmtActionConfirmationRequestBodyPut,
 options?: SecondParameter<typeof axiosInstance>,) => {
      
      
      return axiosInstance<void>(
      {url: `/rest/v1/targets/${targetId}/actions/${actionId}/confirmation`, method: 'PUT',
      headers: {'Content-Type': 'application/hal+json', },
      data: mgmtActionConfirmationRequestBodyPut
    },
      options);
    }
  


export const getUpdateActionConfirmationMutationOptions = <TError = ExceptionInfo,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateActionConfirmation>>, TError,{targetId: string;actionId: number;data: MgmtActionConfirmationRequestBodyPut}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updateActionConfirmation>>, TError,{targetId: string;actionId: number;data: MgmtActionConfirmationRequestBodyPut}, TContext> => {

const mutationKey = ['updateActionConfirmation'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateActionConfirmation>>, {targetId: string;actionId: number;data: MgmtActionConfirmationRequestBodyPut}> = (props) => {
          const {targetId,actionId,data} = props ?? {};

          return  updateActionConfirmation(targetId,actionId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateActionConfirmationMutationResult = NonNullable<Awaited<ReturnType<typeof updateActionConfirmation>>>
    export type UpdateActionConfirmationMutationBody = MgmtActionConfirmationRequestBodyPut
    export type UpdateActionConfirmationMutationError = ExceptionInfo

    /**
 * @summary Controls (confirm/deny) actions waiting for confirmation
 */
export const useUpdateActionConfirmation = <TError = ExceptionInfo,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateActionConfirmation>>, TError,{targetId: string;actionId: number;data: MgmtActionConfirmationRequestBodyPut}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateActionConfirmation>>,
        TError,
        {targetId: string;actionId: number;data: MgmtActionConfirmationRequestBodyPut},
        TContext
      > => {

      const mutationOptions = getUpdateActionConfirmationMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Handles the GET request of retrieving all targets. Required permission: READ_TARGET
 * @summary Return all targets
 */
export const getTargets = (
    params?: GetTargetsParams,
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      
      
      return axiosInstance<PagedListMgmtTarget>(
      {url: `/rest/v1/targets`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getGetTargetsInfiniteQueryKey = (params?: GetTargetsParams,) => {
    return [
    'infinite', `/rest/v1/targets`, ...(params ? [params]: [])
    ] as const;
    }

export const getGetTargetsQueryKey = (params?: GetTargetsParams,) => {
    return [
    `/rest/v1/targets`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetTargetsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getTargets>>, GetTargetsParams['offset']>, TError = ExceptionInfo>(params?: GetTargetsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTargets>>, TError, TData, QueryKey, GetTargetsParams['offset']>>, request?: SecondParameter<typeof axiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTargetsInfiniteQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTargets>>, QueryKey, GetTargetsParams['offset']> = ({ signal, pageParam }) => getTargets({...params, 'offset': pageParam || params?.['offset']}, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTargets>>, TError, TData, QueryKey, GetTargetsParams['offset']> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetTargetsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getTargets>>>
export type GetTargetsInfiniteQueryError = ExceptionInfo


export function useGetTargetsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getTargets>>, GetTargetsParams['offset']>, TError = ExceptionInfo>(
 params: undefined |  GetTargetsParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTargets>>, TError, TData, QueryKey, GetTargetsParams['offset']>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTargets>>,
          TError,
          Awaited<ReturnType<typeof getTargets>>, QueryKey
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTargetsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getTargets>>, GetTargetsParams['offset']>, TError = ExceptionInfo>(
 params?: GetTargetsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTargets>>, TError, TData, QueryKey, GetTargetsParams['offset']>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTargets>>,
          TError,
          Awaited<ReturnType<typeof getTargets>>, QueryKey
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTargetsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getTargets>>, GetTargetsParams['offset']>, TError = ExceptionInfo>(
 params?: GetTargetsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTargets>>, TError, TData, QueryKey, GetTargetsParams['offset']>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Return all targets
 */

export function useGetTargetsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getTargets>>, GetTargetsParams['offset']>, TError = ExceptionInfo>(
 params?: GetTargetsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTargets>>, TError, TData, QueryKey, GetTargetsParams['offset']>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetTargetsInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions, queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getGetTargetsQueryOptions = <TData = Awaited<ReturnType<typeof getTargets>>, TError = ExceptionInfo>(params?: GetTargetsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTargets>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTargetsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTargets>>> = ({ signal }) => getTargets(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getTargets>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetTargetsQueryResult = NonNullable<Awaited<ReturnType<typeof getTargets>>>
export type GetTargetsQueryError = ExceptionInfo


export function useGetTargets<TData = Awaited<ReturnType<typeof getTargets>>, TError = ExceptionInfo>(
 params: undefined |  GetTargetsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTargets>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTargets>>,
          TError,
          Awaited<ReturnType<typeof getTargets>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTargets<TData = Awaited<ReturnType<typeof getTargets>>, TError = ExceptionInfo>(
 params?: GetTargetsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTargets>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTargets>>,
          TError,
          Awaited<ReturnType<typeof getTargets>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTargets<TData = Awaited<ReturnType<typeof getTargets>>, TError = ExceptionInfo>(
 params?: GetTargetsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTargets>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Return all targets
 */

export function useGetTargets<TData = Awaited<ReturnType<typeof getTargets>>, TError = ExceptionInfo>(
 params?: GetTargetsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTargets>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetTargetsQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Handles the POST request of creating new targets. The request body must always be a list of targets. Required Permission: CREATE_TARGET
 * @summary Create target(s)
 */
export const createTargets = (
    mgmtTargetRequestBody: MgmtTargetRequestBody[],
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      
      
      return axiosInstance<MgmtTarget[]>(
      {url: `/rest/v1/targets`, method: 'POST',
      headers: {'Content-Type': 'application/hal+json', },
      data: mgmtTargetRequestBody, signal
    },
      options);
    }
  


export const getCreateTargetsMutationOptions = <TError = ExceptionInfo,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createTargets>>, TError,{data: MgmtTargetRequestBody[]}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createTargets>>, TError,{data: MgmtTargetRequestBody[]}, TContext> => {

const mutationKey = ['createTargets'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createTargets>>, {data: MgmtTargetRequestBody[]}> = (props) => {
          const {data} = props ?? {};

          return  createTargets(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateTargetsMutationResult = NonNullable<Awaited<ReturnType<typeof createTargets>>>
    export type CreateTargetsMutationBody = MgmtTargetRequestBody[]
    export type CreateTargetsMutationError = ExceptionInfo

    /**
 * @summary Create target(s)
 */
export const useCreateTargets = <TError = ExceptionInfo,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createTargets>>, TError,{data: MgmtTargetRequestBody[]}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createTargets>>,
        TError,
        {data: MgmtTargetRequestBody[]},
        TContext
      > => {

      const mutationOptions = getCreateTargetsMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Assign or update the target type of a target. Required permission: UPDATE_TARGET
 * @summary Assign target type to a target
 */
export const assignTargetType = (
    targetId: string,
    mgmtId: MgmtId,
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      
      
      return axiosInstance<void>(
      {url: `/rest/v1/targets/${targetId}/targettype`, method: 'POST',
      headers: {'Content-Type': 'application/hal+json', },
      data: mgmtId, signal
    },
      options);
    }
  


export const getAssignTargetTypeMutationOptions = <TError = ExceptionInfo,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof assignTargetType>>, TError,{targetId: string;data: MgmtId}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof assignTargetType>>, TError,{targetId: string;data: MgmtId}, TContext> => {

const mutationKey = ['assignTargetType'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof assignTargetType>>, {targetId: string;data: MgmtId}> = (props) => {
          const {targetId,data} = props ?? {};

          return  assignTargetType(targetId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AssignTargetTypeMutationResult = NonNullable<Awaited<ReturnType<typeof assignTargetType>>>
    export type AssignTargetTypeMutationBody = MgmtId
    export type AssignTargetTypeMutationError = ExceptionInfo

    /**
 * @summary Assign target type to a target
 */
export const useAssignTargetType = <TError = ExceptionInfo,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof assignTargetType>>, TError,{targetId: string;data: MgmtId}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof assignTargetType>>,
        TError,
        {targetId: string;data: MgmtId},
        TContext
      > => {

      const mutationOptions = getAssignTargetTypeMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Remove the target type from a target. The target type will be set to null. Required permission: UPDATE_TARGET
 * @summary Unassign target type from target.
 */
export const unassignTargetType = (
    targetId: string,
 options?: SecondParameter<typeof axiosInstance>,) => {
      
      
      return axiosInstance<void>(
      {url: `/rest/v1/targets/${targetId}/targettype`, method: 'DELETE'
    },
      options);
    }
  


export const getUnassignTargetTypeMutationOptions = <TError = ExceptionInfo,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof unassignTargetType>>, TError,{targetId: string}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof unassignTargetType>>, TError,{targetId: string}, TContext> => {

const mutationKey = ['unassignTargetType'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof unassignTargetType>>, {targetId: string}> = (props) => {
          const {targetId} = props ?? {};

          return  unassignTargetType(targetId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UnassignTargetTypeMutationResult = NonNullable<Awaited<ReturnType<typeof unassignTargetType>>>
    
    export type UnassignTargetTypeMutationError = ExceptionInfo

    /**
 * @summary Unassign target type from target.
 */
export const useUnassignTargetType = <TError = ExceptionInfo,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof unassignTargetType>>, TError,{targetId: string}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof unassignTargetType>>,
        TError,
        {targetId: string},
        TContext
      > => {

      const mutationOptions = getUnassignTargetTypeMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Get a paged list of metadata for a target. Required permission: READ_REPOSITORY
 * @summary Return metadata for specific target
 */
export const getMetadata = (
    targetId: string,
    params?: GetMetadataParams,
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      
      
      return axiosInstance<PagedListMgmtMetadata>(
      {url: `/rest/v1/targets/${targetId}/metadata`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getGetMetadataInfiniteQueryKey = (targetId?: string,
    params?: GetMetadataParams,) => {
    return [
    'infinite', `/rest/v1/targets/${targetId}/metadata`, ...(params ? [params]: [])
    ] as const;
    }

export const getGetMetadataQueryKey = (targetId?: string,
    params?: GetMetadataParams,) => {
    return [
    `/rest/v1/targets/${targetId}/metadata`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetMetadataInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getMetadata>>, GetMetadataParams['offset']>, TError = ExceptionInfo>(targetId: string,
    params?: GetMetadataParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMetadata>>, TError, TData, QueryKey, GetMetadataParams['offset']>>, request?: SecondParameter<typeof axiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMetadataInfiniteQueryKey(targetId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMetadata>>, QueryKey, GetMetadataParams['offset']> = ({ signal, pageParam }) => getMetadata(targetId,{...params, 'offset': pageParam || params?.['offset']}, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(targetId), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMetadata>>, TError, TData, QueryKey, GetMetadataParams['offset']> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetMetadataInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getMetadata>>>
export type GetMetadataInfiniteQueryError = ExceptionInfo


export function useGetMetadataInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getMetadata>>, GetMetadataParams['offset']>, TError = ExceptionInfo>(
 targetId: string,
    params: undefined |  GetMetadataParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMetadata>>, TError, TData, QueryKey, GetMetadataParams['offset']>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMetadata>>,
          TError,
          Awaited<ReturnType<typeof getMetadata>>, QueryKey
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetMetadataInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getMetadata>>, GetMetadataParams['offset']>, TError = ExceptionInfo>(
 targetId: string,
    params?: GetMetadataParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMetadata>>, TError, TData, QueryKey, GetMetadataParams['offset']>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMetadata>>,
          TError,
          Awaited<ReturnType<typeof getMetadata>>, QueryKey
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetMetadataInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getMetadata>>, GetMetadataParams['offset']>, TError = ExceptionInfo>(
 targetId: string,
    params?: GetMetadataParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMetadata>>, TError, TData, QueryKey, GetMetadataParams['offset']>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Return metadata for specific target
 */

export function useGetMetadataInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getMetadata>>, GetMetadataParams['offset']>, TError = ExceptionInfo>(
 targetId: string,
    params?: GetMetadataParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMetadata>>, TError, TData, QueryKey, GetMetadataParams['offset']>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetMetadataInfiniteQueryOptions(targetId,params,options)

  const query = useInfiniteQuery(queryOptions, queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getGetMetadataQueryOptions = <TData = Awaited<ReturnType<typeof getMetadata>>, TError = ExceptionInfo>(targetId: string,
    params?: GetMetadataParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMetadata>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMetadataQueryKey(targetId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMetadata>>> = ({ signal }) => getMetadata(targetId,params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(targetId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMetadata>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetMetadataQueryResult = NonNullable<Awaited<ReturnType<typeof getMetadata>>>
export type GetMetadataQueryError = ExceptionInfo


export function useGetMetadata<TData = Awaited<ReturnType<typeof getMetadata>>, TError = ExceptionInfo>(
 targetId: string,
    params: undefined |  GetMetadataParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMetadata>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMetadata>>,
          TError,
          Awaited<ReturnType<typeof getMetadata>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetMetadata<TData = Awaited<ReturnType<typeof getMetadata>>, TError = ExceptionInfo>(
 targetId: string,
    params?: GetMetadataParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMetadata>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMetadata>>,
          TError,
          Awaited<ReturnType<typeof getMetadata>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetMetadata<TData = Awaited<ReturnType<typeof getMetadata>>, TError = ExceptionInfo>(
 targetId: string,
    params?: GetMetadataParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMetadata>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Return metadata for specific target
 */

export function useGetMetadata<TData = Awaited<ReturnType<typeof getMetadata>>, TError = ExceptionInfo>(
 targetId: string,
    params?: GetMetadataParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMetadata>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetMetadataQueryOptions(targetId,params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Create a list of metadata entries Required permissions: READ_REPOSITORY and UPDATE_TARGET
 * @summary Create a list of metadata for a specific target
 */
export const createMetadata = (
    targetId: string,
    mgmtMetadata: MgmtMetadata[],
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      
      
      return axiosInstance<MgmtMetadata[]>(
      {url: `/rest/v1/targets/${targetId}/metadata`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: mgmtMetadata, signal
    },
      options);
    }
  


export const getCreateMetadataMutationOptions = <TError = ExceptionInfo,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createMetadata>>, TError,{targetId: string;data: MgmtMetadata[]}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createMetadata>>, TError,{targetId: string;data: MgmtMetadata[]}, TContext> => {

const mutationKey = ['createMetadata'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createMetadata>>, {targetId: string;data: MgmtMetadata[]}> = (props) => {
          const {targetId,data} = props ?? {};

          return  createMetadata(targetId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateMetadataMutationResult = NonNullable<Awaited<ReturnType<typeof createMetadata>>>
    export type CreateMetadataMutationBody = MgmtMetadata[]
    export type CreateMetadataMutationError = ExceptionInfo

    /**
 * @summary Create a list of metadata for a specific target
 */
export const useCreateMetadata = <TError = ExceptionInfo,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createMetadata>>, TError,{targetId: string;data: MgmtMetadata[]}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createMetadata>>,
        TError,
        {targetId: string;data: MgmtMetadata[]},
        TContext
      > => {

      const mutationOptions = getCreateMetadataMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Handles the POST request to deactivate auto-confirmation for a specific target. All active actions will remain unchanged while all future actions need to be confirmed, before processing with the deployment. Required Permission: UPDATE_TARGET
 * @summary Deactivate auto-confirm on a specific target
 */
export const deactivateAutoConfirm = (
    targetId: string,
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      
      
      return axiosInstance<void>(
      {url: `/rest/v1/targets/${targetId}/autoConfirm/deactivate`, method: 'POST', signal
    },
      options);
    }
  


export const getDeactivateAutoConfirmMutationOptions = <TError = ExceptionInfo,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deactivateAutoConfirm>>, TError,{targetId: string}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deactivateAutoConfirm>>, TError,{targetId: string}, TContext> => {

const mutationKey = ['deactivateAutoConfirm'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deactivateAutoConfirm>>, {targetId: string}> = (props) => {
          const {targetId} = props ?? {};

          return  deactivateAutoConfirm(targetId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeactivateAutoConfirmMutationResult = NonNullable<Awaited<ReturnType<typeof deactivateAutoConfirm>>>
    
    export type DeactivateAutoConfirmMutationError = ExceptionInfo

    /**
 * @summary Deactivate auto-confirm on a specific target
 */
export const useDeactivateAutoConfirm = <TError = ExceptionInfo,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deactivateAutoConfirm>>, TError,{targetId: string}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deactivateAutoConfirm>>,
        TError,
        {targetId: string},
        TContext
      > => {

      const mutationOptions = getDeactivateAutoConfirmMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Handles the POST request to activate auto-confirmation for a specific target. As a result all current active as well as future actions will automatically be confirmed by mentioning the initiator as triggered person. Actions will be automatically confirmed, as long as auto-confirmation is active. Required Permission: UPDATE_TARGET
 * @summary Activate auto-confirm on a specific target
 */
export const activateAutoConfirm = (
    targetId: string,
    mgmtTargetAutoConfirmUpdate: MgmtTargetAutoConfirmUpdate,
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      
      
      return axiosInstance<void>(
      {url: `/rest/v1/targets/${targetId}/autoConfirm/activate`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: mgmtTargetAutoConfirmUpdate, signal
    },
      options);
    }
  


export const getActivateAutoConfirmMutationOptions = <TError = ExceptionInfo,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof activateAutoConfirm>>, TError,{targetId: string;data: MgmtTargetAutoConfirmUpdate}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof activateAutoConfirm>>, TError,{targetId: string;data: MgmtTargetAutoConfirmUpdate}, TContext> => {

const mutationKey = ['activateAutoConfirm'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof activateAutoConfirm>>, {targetId: string;data: MgmtTargetAutoConfirmUpdate}> = (props) => {
          const {targetId,data} = props ?? {};

          return  activateAutoConfirm(targetId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ActivateAutoConfirmMutationResult = NonNullable<Awaited<ReturnType<typeof activateAutoConfirm>>>
    export type ActivateAutoConfirmMutationBody = MgmtTargetAutoConfirmUpdate
    export type ActivateAutoConfirmMutationError = ExceptionInfo

    /**
 * @summary Activate auto-confirm on a specific target
 */
export const useActivateAutoConfirm = <TError = ExceptionInfo,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof activateAutoConfirm>>, TError,{targetId: string;data: MgmtTargetAutoConfirmUpdate}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof activateAutoConfirm>>,
        TError,
        {targetId: string;data: MgmtTargetAutoConfirmUpdate},
        TContext
      > => {

      const mutationOptions = getActivateAutoConfirmMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Handles the GET request of retrieving the assigned distribution set of an specific target. Required Permission: READ_TARGET
 * @summary Return the assigned distribution set of a specific target
 */
export const getAssignedDistributionSet = (
    targetId: string,
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      
      
      return axiosInstance<MgmtDistributionSet>(
      {url: `/rest/v1/targets/${targetId}/assignedDS`, method: 'GET', signal
    },
      options);
    }
  



export const getGetAssignedDistributionSetInfiniteQueryKey = (targetId?: string,) => {
    return [
    'infinite', `/rest/v1/targets/${targetId}/assignedDS`
    ] as const;
    }

export const getGetAssignedDistributionSetQueryKey = (targetId?: string,) => {
    return [
    `/rest/v1/targets/${targetId}/assignedDS`
    ] as const;
    }

    
export const getGetAssignedDistributionSetInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getAssignedDistributionSet>>>, TError = ExceptionInfo>(targetId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAssignedDistributionSet>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAssignedDistributionSetInfiniteQueryKey(targetId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAssignedDistributionSet>>> = ({ signal }) => getAssignedDistributionSet(targetId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(targetId), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAssignedDistributionSet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAssignedDistributionSetInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAssignedDistributionSet>>>
export type GetAssignedDistributionSetInfiniteQueryError = ExceptionInfo


export function useGetAssignedDistributionSetInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAssignedDistributionSet>>>, TError = ExceptionInfo>(
 targetId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAssignedDistributionSet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAssignedDistributionSet>>,
          TError,
          Awaited<ReturnType<typeof getAssignedDistributionSet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAssignedDistributionSetInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAssignedDistributionSet>>>, TError = ExceptionInfo>(
 targetId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAssignedDistributionSet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAssignedDistributionSet>>,
          TError,
          Awaited<ReturnType<typeof getAssignedDistributionSet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAssignedDistributionSetInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAssignedDistributionSet>>>, TError = ExceptionInfo>(
 targetId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAssignedDistributionSet>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Return the assigned distribution set of a specific target
 */

export function useGetAssignedDistributionSetInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAssignedDistributionSet>>>, TError = ExceptionInfo>(
 targetId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAssignedDistributionSet>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAssignedDistributionSetInfiniteQueryOptions(targetId,options)

  const query = useInfiniteQuery(queryOptions, queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getGetAssignedDistributionSetQueryOptions = <TData = Awaited<ReturnType<typeof getAssignedDistributionSet>>, TError = ExceptionInfo>(targetId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAssignedDistributionSet>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAssignedDistributionSetQueryKey(targetId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAssignedDistributionSet>>> = ({ signal }) => getAssignedDistributionSet(targetId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(targetId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAssignedDistributionSet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAssignedDistributionSetQueryResult = NonNullable<Awaited<ReturnType<typeof getAssignedDistributionSet>>>
export type GetAssignedDistributionSetQueryError = ExceptionInfo


export function useGetAssignedDistributionSet<TData = Awaited<ReturnType<typeof getAssignedDistributionSet>>, TError = ExceptionInfo>(
 targetId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAssignedDistributionSet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAssignedDistributionSet>>,
          TError,
          Awaited<ReturnType<typeof getAssignedDistributionSet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAssignedDistributionSet<TData = Awaited<ReturnType<typeof getAssignedDistributionSet>>, TError = ExceptionInfo>(
 targetId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAssignedDistributionSet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAssignedDistributionSet>>,
          TError,
          Awaited<ReturnType<typeof getAssignedDistributionSet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAssignedDistributionSet<TData = Awaited<ReturnType<typeof getAssignedDistributionSet>>, TError = ExceptionInfo>(
 targetId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAssignedDistributionSet>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Return the assigned distribution set of a specific target
 */

export function useGetAssignedDistributionSet<TData = Awaited<ReturnType<typeof getAssignedDistributionSet>>, TError = ExceptionInfo>(
 targetId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAssignedDistributionSet>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAssignedDistributionSetQueryOptions(targetId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Handles the POST request for assigning a distribution set to a specific target. Required Permission: READ_REPOSITORY and UPDATE_TARGET
 * @summary Assigns a distribution set to a specific target
 */
export const postAssignedDistributionSet = (
    targetId: string,
    mgmtDistributionSetAssignments: MgmtDistributionSetAssignments,
    params?: PostAssignedDistributionSetParams,
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      
      
      return axiosInstance<MgmtTargetAssignmentResponseBody>(
      {url: `/rest/v1/targets/${targetId}/assignedDS`, method: 'POST',
      headers: {'Content-Type': 'application/hal+json', },
      data: mgmtDistributionSetAssignments,
        params, signal
    },
      options);
    }
  


export const getPostAssignedDistributionSetMutationOptions = <TError = ExceptionInfo,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAssignedDistributionSet>>, TError,{targetId: string;data: MgmtDistributionSetAssignments;params?: PostAssignedDistributionSetParams}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postAssignedDistributionSet>>, TError,{targetId: string;data: MgmtDistributionSetAssignments;params?: PostAssignedDistributionSetParams}, TContext> => {

const mutationKey = ['postAssignedDistributionSet'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postAssignedDistributionSet>>, {targetId: string;data: MgmtDistributionSetAssignments;params?: PostAssignedDistributionSetParams}> = (props) => {
          const {targetId,data,params} = props ?? {};

          return  postAssignedDistributionSet(targetId,data,params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostAssignedDistributionSetMutationResult = NonNullable<Awaited<ReturnType<typeof postAssignedDistributionSet>>>
    export type PostAssignedDistributionSetMutationBody = MgmtDistributionSetAssignments
    export type PostAssignedDistributionSetMutationError = ExceptionInfo

    /**
 * @summary Assigns a distribution set to a specific target
 */
export const usePostAssignedDistributionSet = <TError = ExceptionInfo,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAssignedDistributionSet>>, TError,{targetId: string;data: MgmtDistributionSetAssignments;params?: PostAssignedDistributionSetParams}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postAssignedDistributionSet>>,
        TError,
        {targetId: string;data: MgmtDistributionSetAssignments;params?: PostAssignedDistributionSetParams},
        TContext
      > => {

      const mutationOptions = getPostAssignedDistributionSetMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Get a paged list of tags for a target. Required permission: READ_REPOSITORY
 * @summary Return tags for specific target
 */
export const getTags = (
    targetId: string,
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      
      
      return axiosInstance<MgmtTag[]>(
      {url: `/rest/v1/targets/${targetId}/tags`, method: 'GET', signal
    },
      options);
    }
  



export const getGetTagsInfiniteQueryKey = (targetId?: string,) => {
    return [
    'infinite', `/rest/v1/targets/${targetId}/tags`
    ] as const;
    }

export const getGetTagsQueryKey = (targetId?: string,) => {
    return [
    `/rest/v1/targets/${targetId}/tags`
    ] as const;
    }

    
export const getGetTagsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getTags>>>, TError = unknown>(targetId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTags>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTagsInfiniteQueryKey(targetId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTags>>> = ({ signal }) => getTags(targetId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(targetId), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTags>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetTagsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getTags>>>
export type GetTagsInfiniteQueryError = unknown


export function useGetTagsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getTags>>>, TError = unknown>(
 targetId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTags>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTags>>,
          TError,
          Awaited<ReturnType<typeof getTags>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTagsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getTags>>>, TError = unknown>(
 targetId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTags>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTags>>,
          TError,
          Awaited<ReturnType<typeof getTags>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTagsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getTags>>>, TError = unknown>(
 targetId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTags>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Return tags for specific target
 */

export function useGetTagsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getTags>>>, TError = unknown>(
 targetId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTags>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetTagsInfiniteQueryOptions(targetId,options)

  const query = useInfiniteQuery(queryOptions, queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getGetTagsQueryOptions = <TData = Awaited<ReturnType<typeof getTags>>, TError = unknown>(targetId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTags>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTagsQueryKey(targetId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTags>>> = ({ signal }) => getTags(targetId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(targetId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getTags>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetTagsQueryResult = NonNullable<Awaited<ReturnType<typeof getTags>>>
export type GetTagsQueryError = unknown


export function useGetTags<TData = Awaited<ReturnType<typeof getTags>>, TError = unknown>(
 targetId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTags>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTags>>,
          TError,
          Awaited<ReturnType<typeof getTags>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTags<TData = Awaited<ReturnType<typeof getTags>>, TError = unknown>(
 targetId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTags>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTags>>,
          TError,
          Awaited<ReturnType<typeof getTags>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTags<TData = Awaited<ReturnType<typeof getTags>>, TError = unknown>(
 targetId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTags>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Return tags for specific target
 */

export function useGetTags<TData = Awaited<ReturnType<typeof getTags>>, TError = unknown>(
 targetId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTags>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetTagsQueryOptions(targetId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Handles the GET request of retrieving the installed distribution set of an specific target. Required Permission: READ_TARGET
 * @summary Return installed distribution set of a specific target
 */
export const getInstalledDistributionSet = (
    targetId: string,
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      
      
      return axiosInstance<MgmtDistributionSet>(
      {url: `/rest/v1/targets/${targetId}/installedDS`, method: 'GET', signal
    },
      options);
    }
  



export const getGetInstalledDistributionSetInfiniteQueryKey = (targetId?: string,) => {
    return [
    'infinite', `/rest/v1/targets/${targetId}/installedDS`
    ] as const;
    }

export const getGetInstalledDistributionSetQueryKey = (targetId?: string,) => {
    return [
    `/rest/v1/targets/${targetId}/installedDS`
    ] as const;
    }

    
export const getGetInstalledDistributionSetInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getInstalledDistributionSet>>>, TError = ExceptionInfo>(targetId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getInstalledDistributionSet>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetInstalledDistributionSetInfiniteQueryKey(targetId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getInstalledDistributionSet>>> = ({ signal }) => getInstalledDistributionSet(targetId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(targetId), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getInstalledDistributionSet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetInstalledDistributionSetInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getInstalledDistributionSet>>>
export type GetInstalledDistributionSetInfiniteQueryError = ExceptionInfo


export function useGetInstalledDistributionSetInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getInstalledDistributionSet>>>, TError = ExceptionInfo>(
 targetId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getInstalledDistributionSet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInstalledDistributionSet>>,
          TError,
          Awaited<ReturnType<typeof getInstalledDistributionSet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetInstalledDistributionSetInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getInstalledDistributionSet>>>, TError = ExceptionInfo>(
 targetId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getInstalledDistributionSet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInstalledDistributionSet>>,
          TError,
          Awaited<ReturnType<typeof getInstalledDistributionSet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetInstalledDistributionSetInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getInstalledDistributionSet>>>, TError = ExceptionInfo>(
 targetId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getInstalledDistributionSet>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Return installed distribution set of a specific target
 */

export function useGetInstalledDistributionSetInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getInstalledDistributionSet>>>, TError = ExceptionInfo>(
 targetId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getInstalledDistributionSet>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetInstalledDistributionSetInfiniteQueryOptions(targetId,options)

  const query = useInfiniteQuery(queryOptions, queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getGetInstalledDistributionSetQueryOptions = <TData = Awaited<ReturnType<typeof getInstalledDistributionSet>>, TError = ExceptionInfo>(targetId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getInstalledDistributionSet>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetInstalledDistributionSetQueryKey(targetId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getInstalledDistributionSet>>> = ({ signal }) => getInstalledDistributionSet(targetId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(targetId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getInstalledDistributionSet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetInstalledDistributionSetQueryResult = NonNullable<Awaited<ReturnType<typeof getInstalledDistributionSet>>>
export type GetInstalledDistributionSetQueryError = ExceptionInfo


export function useGetInstalledDistributionSet<TData = Awaited<ReturnType<typeof getInstalledDistributionSet>>, TError = ExceptionInfo>(
 targetId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getInstalledDistributionSet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInstalledDistributionSet>>,
          TError,
          Awaited<ReturnType<typeof getInstalledDistributionSet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetInstalledDistributionSet<TData = Awaited<ReturnType<typeof getInstalledDistributionSet>>, TError = ExceptionInfo>(
 targetId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getInstalledDistributionSet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInstalledDistributionSet>>,
          TError,
          Awaited<ReturnType<typeof getInstalledDistributionSet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetInstalledDistributionSet<TData = Awaited<ReturnType<typeof getInstalledDistributionSet>>, TError = ExceptionInfo>(
 targetId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getInstalledDistributionSet>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Return installed distribution set of a specific target
 */

export function useGetInstalledDistributionSet<TData = Awaited<ReturnType<typeof getInstalledDistributionSet>>, TError = ExceptionInfo>(
 targetId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getInstalledDistributionSet>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetInstalledDistributionSetQueryOptions(targetId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Handles the GET request to check the current auto-confirmation state of a target. Required Permission: READ_TARGET
 * @summary Return the current auto-confitm state for a specific target
 */
export const getAutoConfirmStatus = (
    targetId: string,
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      
      
      return axiosInstance<MgmtTargetAutoConfirm>(
      {url: `/rest/v1/targets/${targetId}/autoConfirm`, method: 'GET', signal
    },
      options);
    }
  



export const getGetAutoConfirmStatusInfiniteQueryKey = (targetId?: string,) => {
    return [
    'infinite', `/rest/v1/targets/${targetId}/autoConfirm`
    ] as const;
    }

export const getGetAutoConfirmStatusQueryKey = (targetId?: string,) => {
    return [
    `/rest/v1/targets/${targetId}/autoConfirm`
    ] as const;
    }

    
export const getGetAutoConfirmStatusInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getAutoConfirmStatus>>>, TError = ExceptionInfo>(targetId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAutoConfirmStatus>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAutoConfirmStatusInfiniteQueryKey(targetId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAutoConfirmStatus>>> = ({ signal }) => getAutoConfirmStatus(targetId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(targetId), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAutoConfirmStatus>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAutoConfirmStatusInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAutoConfirmStatus>>>
export type GetAutoConfirmStatusInfiniteQueryError = ExceptionInfo


export function useGetAutoConfirmStatusInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAutoConfirmStatus>>>, TError = ExceptionInfo>(
 targetId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAutoConfirmStatus>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAutoConfirmStatus>>,
          TError,
          Awaited<ReturnType<typeof getAutoConfirmStatus>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAutoConfirmStatusInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAutoConfirmStatus>>>, TError = ExceptionInfo>(
 targetId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAutoConfirmStatus>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAutoConfirmStatus>>,
          TError,
          Awaited<ReturnType<typeof getAutoConfirmStatus>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAutoConfirmStatusInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAutoConfirmStatus>>>, TError = ExceptionInfo>(
 targetId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAutoConfirmStatus>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Return the current auto-confitm state for a specific target
 */

export function useGetAutoConfirmStatusInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAutoConfirmStatus>>>, TError = ExceptionInfo>(
 targetId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAutoConfirmStatus>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAutoConfirmStatusInfiniteQueryOptions(targetId,options)

  const query = useInfiniteQuery(queryOptions, queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getGetAutoConfirmStatusQueryOptions = <TData = Awaited<ReturnType<typeof getAutoConfirmStatus>>, TError = ExceptionInfo>(targetId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAutoConfirmStatus>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAutoConfirmStatusQueryKey(targetId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAutoConfirmStatus>>> = ({ signal }) => getAutoConfirmStatus(targetId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(targetId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAutoConfirmStatus>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAutoConfirmStatusQueryResult = NonNullable<Awaited<ReturnType<typeof getAutoConfirmStatus>>>
export type GetAutoConfirmStatusQueryError = ExceptionInfo


export function useGetAutoConfirmStatus<TData = Awaited<ReturnType<typeof getAutoConfirmStatus>>, TError = ExceptionInfo>(
 targetId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAutoConfirmStatus>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAutoConfirmStatus>>,
          TError,
          Awaited<ReturnType<typeof getAutoConfirmStatus>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAutoConfirmStatus<TData = Awaited<ReturnType<typeof getAutoConfirmStatus>>, TError = ExceptionInfo>(
 targetId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAutoConfirmStatus>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAutoConfirmStatus>>,
          TError,
          Awaited<ReturnType<typeof getAutoConfirmStatus>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAutoConfirmStatus<TData = Awaited<ReturnType<typeof getAutoConfirmStatus>>, TError = ExceptionInfo>(
 targetId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAutoConfirmStatus>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Return the current auto-confitm state for a specific target
 */

export function useGetAutoConfirmStatus<TData = Awaited<ReturnType<typeof getAutoConfirmStatus>>, TError = ExceptionInfo>(
 targetId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAutoConfirmStatus>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAutoConfirmStatusQueryOptions(targetId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Handles the GET request of retrieving the attributes of a specific target. Reponse is a key/value list. Required Permission: READ_TARGET
 * @summary Return attributes of a specific target
 */
export const getAttributes = (
    targetId: string,
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      
      
      return axiosInstance<MgmtTargetAttributes>(
      {url: `/rest/v1/targets/${targetId}/attributes`, method: 'GET', signal
    },
      options);
    }
  



export const getGetAttributesInfiniteQueryKey = (targetId?: string,) => {
    return [
    'infinite', `/rest/v1/targets/${targetId}/attributes`
    ] as const;
    }

export const getGetAttributesQueryKey = (targetId?: string,) => {
    return [
    `/rest/v1/targets/${targetId}/attributes`
    ] as const;
    }

    
export const getGetAttributesInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getAttributes>>>, TError = ExceptionInfo>(targetId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAttributes>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAttributesInfiniteQueryKey(targetId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAttributes>>> = ({ signal }) => getAttributes(targetId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(targetId), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAttributes>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAttributesInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAttributes>>>
export type GetAttributesInfiniteQueryError = ExceptionInfo


export function useGetAttributesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAttributes>>>, TError = ExceptionInfo>(
 targetId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAttributes>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAttributes>>,
          TError,
          Awaited<ReturnType<typeof getAttributes>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAttributesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAttributes>>>, TError = ExceptionInfo>(
 targetId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAttributes>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAttributes>>,
          TError,
          Awaited<ReturnType<typeof getAttributes>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAttributesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAttributes>>>, TError = ExceptionInfo>(
 targetId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAttributes>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Return attributes of a specific target
 */

export function useGetAttributesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAttributes>>>, TError = ExceptionInfo>(
 targetId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAttributes>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAttributesInfiniteQueryOptions(targetId,options)

  const query = useInfiniteQuery(queryOptions, queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getGetAttributesQueryOptions = <TData = Awaited<ReturnType<typeof getAttributes>>, TError = ExceptionInfo>(targetId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAttributes>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAttributesQueryKey(targetId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAttributes>>> = ({ signal }) => getAttributes(targetId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(targetId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAttributes>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAttributesQueryResult = NonNullable<Awaited<ReturnType<typeof getAttributes>>>
export type GetAttributesQueryError = ExceptionInfo


export function useGetAttributes<TData = Awaited<ReturnType<typeof getAttributes>>, TError = ExceptionInfo>(
 targetId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAttributes>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAttributes>>,
          TError,
          Awaited<ReturnType<typeof getAttributes>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAttributes<TData = Awaited<ReturnType<typeof getAttributes>>, TError = ExceptionInfo>(
 targetId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAttributes>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAttributes>>,
          TError,
          Awaited<ReturnType<typeof getAttributes>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAttributes<TData = Awaited<ReturnType<typeof getAttributes>>, TError = ExceptionInfo>(
 targetId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAttributes>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Return attributes of a specific target
 */

export function useGetAttributes<TData = Awaited<ReturnType<typeof getAttributes>>, TError = ExceptionInfo>(
 targetId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAttributes>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAttributesQueryOptions(targetId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Handles the GET request of retrieving the full action history of a specific target. Required Permission: READ_TARGET
 * @summary Return actions for a specific target
 */
export const getActionHistory = (
    targetId: string,
    params?: GetActionHistoryParams,
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      
      
      return axiosInstance<PagedListMgmtAction>(
      {url: `/rest/v1/targets/${targetId}/actions`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getGetActionHistoryInfiniteQueryKey = (targetId?: string,
    params?: GetActionHistoryParams,) => {
    return [
    'infinite', `/rest/v1/targets/${targetId}/actions`, ...(params ? [params]: [])
    ] as const;
    }

export const getGetActionHistoryQueryKey = (targetId?: string,
    params?: GetActionHistoryParams,) => {
    return [
    `/rest/v1/targets/${targetId}/actions`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetActionHistoryInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getActionHistory>>, GetActionHistoryParams['offset']>, TError = ExceptionInfo>(targetId: string,
    params?: GetActionHistoryParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getActionHistory>>, TError, TData, QueryKey, GetActionHistoryParams['offset']>>, request?: SecondParameter<typeof axiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetActionHistoryInfiniteQueryKey(targetId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getActionHistory>>, QueryKey, GetActionHistoryParams['offset']> = ({ signal, pageParam }) => getActionHistory(targetId,{...params, 'offset': pageParam || params?.['offset']}, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(targetId), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getActionHistory>>, TError, TData, QueryKey, GetActionHistoryParams['offset']> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetActionHistoryInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getActionHistory>>>
export type GetActionHistoryInfiniteQueryError = ExceptionInfo


export function useGetActionHistoryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getActionHistory>>, GetActionHistoryParams['offset']>, TError = ExceptionInfo>(
 targetId: string,
    params: undefined |  GetActionHistoryParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getActionHistory>>, TError, TData, QueryKey, GetActionHistoryParams['offset']>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getActionHistory>>,
          TError,
          Awaited<ReturnType<typeof getActionHistory>>, QueryKey
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetActionHistoryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getActionHistory>>, GetActionHistoryParams['offset']>, TError = ExceptionInfo>(
 targetId: string,
    params?: GetActionHistoryParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getActionHistory>>, TError, TData, QueryKey, GetActionHistoryParams['offset']>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getActionHistory>>,
          TError,
          Awaited<ReturnType<typeof getActionHistory>>, QueryKey
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetActionHistoryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getActionHistory>>, GetActionHistoryParams['offset']>, TError = ExceptionInfo>(
 targetId: string,
    params?: GetActionHistoryParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getActionHistory>>, TError, TData, QueryKey, GetActionHistoryParams['offset']>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Return actions for a specific target
 */

export function useGetActionHistoryInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getActionHistory>>, GetActionHistoryParams['offset']>, TError = ExceptionInfo>(
 targetId: string,
    params?: GetActionHistoryParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getActionHistory>>, TError, TData, QueryKey, GetActionHistoryParams['offset']>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetActionHistoryInfiniteQueryOptions(targetId,params,options)

  const query = useInfiniteQuery(queryOptions, queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getGetActionHistoryQueryOptions = <TData = Awaited<ReturnType<typeof getActionHistory>>, TError = ExceptionInfo>(targetId: string,
    params?: GetActionHistoryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getActionHistory>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetActionHistoryQueryKey(targetId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getActionHistory>>> = ({ signal }) => getActionHistory(targetId,params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(targetId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getActionHistory>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetActionHistoryQueryResult = NonNullable<Awaited<ReturnType<typeof getActionHistory>>>
export type GetActionHistoryQueryError = ExceptionInfo


export function useGetActionHistory<TData = Awaited<ReturnType<typeof getActionHistory>>, TError = ExceptionInfo>(
 targetId: string,
    params: undefined |  GetActionHistoryParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getActionHistory>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getActionHistory>>,
          TError,
          Awaited<ReturnType<typeof getActionHistory>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetActionHistory<TData = Awaited<ReturnType<typeof getActionHistory>>, TError = ExceptionInfo>(
 targetId: string,
    params?: GetActionHistoryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getActionHistory>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getActionHistory>>,
          TError,
          Awaited<ReturnType<typeof getActionHistory>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetActionHistory<TData = Awaited<ReturnType<typeof getActionHistory>>, TError = ExceptionInfo>(
 targetId: string,
    params?: GetActionHistoryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getActionHistory>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Return actions for a specific target
 */

export function useGetActionHistory<TData = Awaited<ReturnType<typeof getActionHistory>>, TError = ExceptionInfo>(
 targetId: string,
    params?: GetActionHistoryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getActionHistory>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetActionHistoryQueryOptions(targetId,params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Handles the GET request of retrieving a specific action on a specific target. Required Permission: READ_TARGET
 * @summary Return status of a specific action on a specific target
 */
export const getActionStatusList = (
    targetId: string,
    actionId: number,
    params?: GetActionStatusListParams,
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      
      
      return axiosInstance<PagedListMgmtActionStatus>(
      {url: `/rest/v1/targets/${targetId}/actions/${actionId}/status`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getGetActionStatusListInfiniteQueryKey = (targetId?: string,
    actionId?: number,
    params?: GetActionStatusListParams,) => {
    return [
    'infinite', `/rest/v1/targets/${targetId}/actions/${actionId}/status`, ...(params ? [params]: [])
    ] as const;
    }

export const getGetActionStatusListQueryKey = (targetId?: string,
    actionId?: number,
    params?: GetActionStatusListParams,) => {
    return [
    `/rest/v1/targets/${targetId}/actions/${actionId}/status`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetActionStatusListInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getActionStatusList>>, GetActionStatusListParams['offset']>, TError = ExceptionInfo>(targetId: string,
    actionId: number,
    params?: GetActionStatusListParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getActionStatusList>>, TError, TData, QueryKey, GetActionStatusListParams['offset']>>, request?: SecondParameter<typeof axiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetActionStatusListInfiniteQueryKey(targetId,actionId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getActionStatusList>>, QueryKey, GetActionStatusListParams['offset']> = ({ signal, pageParam }) => getActionStatusList(targetId,actionId,{...params, 'offset': pageParam || params?.['offset']}, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(targetId && actionId), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getActionStatusList>>, TError, TData, QueryKey, GetActionStatusListParams['offset']> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetActionStatusListInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getActionStatusList>>>
export type GetActionStatusListInfiniteQueryError = ExceptionInfo


export function useGetActionStatusListInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getActionStatusList>>, GetActionStatusListParams['offset']>, TError = ExceptionInfo>(
 targetId: string,
    actionId: number,
    params: undefined |  GetActionStatusListParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getActionStatusList>>, TError, TData, QueryKey, GetActionStatusListParams['offset']>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getActionStatusList>>,
          TError,
          Awaited<ReturnType<typeof getActionStatusList>>, QueryKey
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetActionStatusListInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getActionStatusList>>, GetActionStatusListParams['offset']>, TError = ExceptionInfo>(
 targetId: string,
    actionId: number,
    params?: GetActionStatusListParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getActionStatusList>>, TError, TData, QueryKey, GetActionStatusListParams['offset']>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getActionStatusList>>,
          TError,
          Awaited<ReturnType<typeof getActionStatusList>>, QueryKey
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetActionStatusListInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getActionStatusList>>, GetActionStatusListParams['offset']>, TError = ExceptionInfo>(
 targetId: string,
    actionId: number,
    params?: GetActionStatusListParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getActionStatusList>>, TError, TData, QueryKey, GetActionStatusListParams['offset']>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Return status of a specific action on a specific target
 */

export function useGetActionStatusListInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getActionStatusList>>, GetActionStatusListParams['offset']>, TError = ExceptionInfo>(
 targetId: string,
    actionId: number,
    params?: GetActionStatusListParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getActionStatusList>>, TError, TData, QueryKey, GetActionStatusListParams['offset']>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetActionStatusListInfiniteQueryOptions(targetId,actionId,params,options)

  const query = useInfiniteQuery(queryOptions, queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getGetActionStatusListQueryOptions = <TData = Awaited<ReturnType<typeof getActionStatusList>>, TError = ExceptionInfo>(targetId: string,
    actionId: number,
    params?: GetActionStatusListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getActionStatusList>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetActionStatusListQueryKey(targetId,actionId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getActionStatusList>>> = ({ signal }) => getActionStatusList(targetId,actionId,params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(targetId && actionId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getActionStatusList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetActionStatusListQueryResult = NonNullable<Awaited<ReturnType<typeof getActionStatusList>>>
export type GetActionStatusListQueryError = ExceptionInfo


export function useGetActionStatusList<TData = Awaited<ReturnType<typeof getActionStatusList>>, TError = ExceptionInfo>(
 targetId: string,
    actionId: number,
    params: undefined |  GetActionStatusListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getActionStatusList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getActionStatusList>>,
          TError,
          Awaited<ReturnType<typeof getActionStatusList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetActionStatusList<TData = Awaited<ReturnType<typeof getActionStatusList>>, TError = ExceptionInfo>(
 targetId: string,
    actionId: number,
    params?: GetActionStatusListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getActionStatusList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getActionStatusList>>,
          TError,
          Awaited<ReturnType<typeof getActionStatusList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetActionStatusList<TData = Awaited<ReturnType<typeof getActionStatusList>>, TError = ExceptionInfo>(
 targetId: string,
    actionId: number,
    params?: GetActionStatusListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getActionStatusList>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Return status of a specific action on a specific target
 */

export function useGetActionStatusList<TData = Awaited<ReturnType<typeof getActionStatusList>>, TError = ExceptionInfo>(
 targetId: string,
    actionId: number,
    params?: GetActionStatusListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getActionStatusList>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetActionStatusListQueryOptions(targetId,actionId,params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




