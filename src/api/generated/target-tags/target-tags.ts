/**
 * Generated by orval v7.17.0 üç∫
 * Do not edit manually.
 * hawkBit REST APIs
 * Eclipse hawkBit‚Ñ¢ is a domain-independent back-end framework for rolling out software updates to constrained edge devices as well as more powerful controllers and gateways connected to IP based networking infrastructure.

 * OpenAPI spec version: v1
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  AssignTargetsParams,
  ExceptionInfo,
  GetAssignedTargetsParams,
  GetTargetTagsParams,
  MgmtTag,
  MgmtTagRequestBodyPut,
  PagedListMgmtTag,
  PagedListMgmtTarget,
  UnassignTargetsParams
} from '.././model';

import { axiosInstance } from '../../axios-instance';


type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * Handles the GET request of retrieving a single target tag.
 * @summary Return target tag by id
 */
export const getTargetTag = (
    targetTagId: number,
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      
      
      return axiosInstance<MgmtTag>(
      {url: `/rest/v1/targettags/${targetTagId}`, method: 'GET', signal
    },
      options);
    }
  



export const getGetTargetTagQueryKey = (targetTagId?: number,) => {
    return [
    `/rest/v1/targettags/${targetTagId}`
    ] as const;
    }

    
export const getGetTargetTagQueryOptions = <TData = Awaited<ReturnType<typeof getTargetTag>>, TError = ExceptionInfo | MgmtTag>(targetTagId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTargetTag>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTargetTagQueryKey(targetTagId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTargetTag>>> = ({ signal }) => getTargetTag(targetTagId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(targetTagId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getTargetTag>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetTargetTagQueryResult = NonNullable<Awaited<ReturnType<typeof getTargetTag>>>
export type GetTargetTagQueryError = ExceptionInfo | MgmtTag


export function useGetTargetTag<TData = Awaited<ReturnType<typeof getTargetTag>>, TError = ExceptionInfo | MgmtTag>(
 targetTagId: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTargetTag>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTargetTag>>,
          TError,
          Awaited<ReturnType<typeof getTargetTag>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTargetTag<TData = Awaited<ReturnType<typeof getTargetTag>>, TError = ExceptionInfo | MgmtTag>(
 targetTagId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTargetTag>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTargetTag>>,
          TError,
          Awaited<ReturnType<typeof getTargetTag>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTargetTag<TData = Awaited<ReturnType<typeof getTargetTag>>, TError = ExceptionInfo | MgmtTag>(
 targetTagId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTargetTag>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Return target tag by id
 */

export function useGetTargetTag<TData = Awaited<ReturnType<typeof getTargetTag>>, TError = ExceptionInfo | MgmtTag>(
 targetTagId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTargetTag>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetTargetTagQueryOptions(targetTagId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Handles the PUT request of updating a target tag.
 * @summary Update target tag by id
 */
export const updateTargetTag = (
    targetTagId: number,
    mgmtTagRequestBodyPut: MgmtTagRequestBodyPut,
 options?: SecondParameter<typeof axiosInstance>,) => {
      
      
      return axiosInstance<MgmtTag>(
      {url: `/rest/v1/targettags/${targetTagId}`, method: 'PUT',
      headers: {'Content-Type': 'application/hal+json', },
      data: mgmtTagRequestBodyPut
    },
      options);
    }
  


export const getUpdateTargetTagMutationOptions = <TError = ExceptionInfo | MgmtTag,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateTargetTag>>, TError,{targetTagId: number;data: MgmtTagRequestBodyPut}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updateTargetTag>>, TError,{targetTagId: number;data: MgmtTagRequestBodyPut}, TContext> => {

const mutationKey = ['updateTargetTag'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateTargetTag>>, {targetTagId: number;data: MgmtTagRequestBodyPut}> = (props) => {
          const {targetTagId,data} = props ?? {};

          return  updateTargetTag(targetTagId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateTargetTagMutationResult = NonNullable<Awaited<ReturnType<typeof updateTargetTag>>>
    export type UpdateTargetTagMutationBody = MgmtTagRequestBodyPut
    export type UpdateTargetTagMutationError = ExceptionInfo | MgmtTag

    /**
 * @summary Update target tag by id
 */
export const useUpdateTargetTag = <TError = ExceptionInfo | MgmtTag,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateTargetTag>>, TError,{targetTagId: number;data: MgmtTagRequestBodyPut}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateTargetTag>>,
        TError,
        {targetTagId: number;data: MgmtTagRequestBodyPut},
        TContext
      > => {

      const mutationOptions = getUpdateTargetTagMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Handles the DELETE request of deleting a single target tag.
 * @summary Delete target tag by id
 */
export const deleteTargetTag = (
    targetTagId: number,
 options?: SecondParameter<typeof axiosInstance>,) => {
      
      
      return axiosInstance<void>(
      {url: `/rest/v1/targettags/${targetTagId}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteTargetTagMutationOptions = <TError = ExceptionInfo | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteTargetTag>>, TError,{targetTagId: number}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteTargetTag>>, TError,{targetTagId: number}, TContext> => {

const mutationKey = ['deleteTargetTag'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteTargetTag>>, {targetTagId: number}> = (props) => {
          const {targetTagId} = props ?? {};

          return  deleteTargetTag(targetTagId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteTargetTagMutationResult = NonNullable<Awaited<ReturnType<typeof deleteTargetTag>>>
    
    export type DeleteTargetTagMutationError = ExceptionInfo | void

    /**
 * @summary Delete target tag by id
 */
export const useDeleteTargetTag = <TError = ExceptionInfo | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteTargetTag>>, TError,{targetTagId: number}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteTargetTag>>,
        TError,
        {targetTagId: number},
        TContext
      > => {

      const mutationOptions = getDeleteTargetTagMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Handles the GET request of retrieving a list of assigned targets.
 * @summary Return assigned targets for tag
 */
export const getAssignedTargets = (
    targetTagId: number,
    params?: GetAssignedTargetsParams,
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      
      
      return axiosInstance<PagedListMgmtTarget>(
      {url: `/rest/v1/targettags/${targetTagId}/assigned`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getGetAssignedTargetsQueryKey = (targetTagId?: number,
    params?: GetAssignedTargetsParams,) => {
    return [
    `/rest/v1/targettags/${targetTagId}/assigned`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetAssignedTargetsQueryOptions = <TData = Awaited<ReturnType<typeof getAssignedTargets>>, TError = ExceptionInfo | PagedListMgmtTarget>(targetTagId: number,
    params?: GetAssignedTargetsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAssignedTargets>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAssignedTargetsQueryKey(targetTagId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAssignedTargets>>> = ({ signal }) => getAssignedTargets(targetTagId,params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(targetTagId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAssignedTargets>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAssignedTargetsQueryResult = NonNullable<Awaited<ReturnType<typeof getAssignedTargets>>>
export type GetAssignedTargetsQueryError = ExceptionInfo | PagedListMgmtTarget


export function useGetAssignedTargets<TData = Awaited<ReturnType<typeof getAssignedTargets>>, TError = ExceptionInfo | PagedListMgmtTarget>(
 targetTagId: number,
    params: undefined |  GetAssignedTargetsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAssignedTargets>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAssignedTargets>>,
          TError,
          Awaited<ReturnType<typeof getAssignedTargets>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAssignedTargets<TData = Awaited<ReturnType<typeof getAssignedTargets>>, TError = ExceptionInfo | PagedListMgmtTarget>(
 targetTagId: number,
    params?: GetAssignedTargetsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAssignedTargets>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAssignedTargets>>,
          TError,
          Awaited<ReturnType<typeof getAssignedTargets>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAssignedTargets<TData = Awaited<ReturnType<typeof getAssignedTargets>>, TError = ExceptionInfo | PagedListMgmtTarget>(
 targetTagId: number,
    params?: GetAssignedTargetsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAssignedTargets>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Return assigned targets for tag
 */

export function useGetAssignedTargets<TData = Awaited<ReturnType<typeof getAssignedTargets>>, TError = ExceptionInfo | PagedListMgmtTarget>(
 targetTagId: number,
    params?: GetAssignedTargetsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAssignedTargets>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAssignedTargetsQueryOptions(targetTagId,params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Handles the POST request of target assignment. Already assigned target will be ignored.
 * @summary Assign target(s) to given tagId
 */
export const assignTargets = (
    targetTagId: number,
    assignTargetsBody: string[],
    params?: AssignTargetsParams,
 options?: SecondParameter<typeof axiosInstance>,) => {
      
      
      return axiosInstance<void>(
      {url: `/rest/v1/targettags/${targetTagId}/assigned`, method: 'PUT',
      headers: {'Content-Type': 'application/hal+json', },
      data: assignTargetsBody,
        params
    },
      options);
    }
  


export const getAssignTargetsMutationOptions = <TError = ExceptionInfo | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof assignTargets>>, TError,{targetTagId: number;data: string[];params?: AssignTargetsParams}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof assignTargets>>, TError,{targetTagId: number;data: string[];params?: AssignTargetsParams}, TContext> => {

const mutationKey = ['assignTargets'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof assignTargets>>, {targetTagId: number;data: string[];params?: AssignTargetsParams}> = (props) => {
          const {targetTagId,data,params} = props ?? {};

          return  assignTargets(targetTagId,data,params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AssignTargetsMutationResult = NonNullable<Awaited<ReturnType<typeof assignTargets>>>
    export type AssignTargetsMutationBody = string[]
    export type AssignTargetsMutationError = ExceptionInfo | void

    /**
 * @summary Assign target(s) to given tagId
 */
export const useAssignTargets = <TError = ExceptionInfo | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof assignTargets>>, TError,{targetTagId: number;data: string[];params?: AssignTargetsParams}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof assignTargets>>,
        TError,
        {targetTagId: number;data: string[];params?: AssignTargetsParams},
        TContext
      > => {

      const mutationOptions = getAssignTargetsMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Handles the DELETE request to unassign the given targets.
 * @summary Unassign targets from a given tagId
 */
export const unassignTargets = (
    targetTagId: number,
    unassignTargetsBody: string[],
    params?: UnassignTargetsParams,
 options?: SecondParameter<typeof axiosInstance>,) => {
      
      
      return axiosInstance<void>(
      {url: `/rest/v1/targettags/${targetTagId}/assigned`, method: 'DELETE',
      headers: {'Content-Type': 'application/hal+json', },
      data: unassignTargetsBody,
        params
    },
      options);
    }
  


export const getUnassignTargetsMutationOptions = <TError = ExceptionInfo | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof unassignTargets>>, TError,{targetTagId: number;data: string[];params?: UnassignTargetsParams}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof unassignTargets>>, TError,{targetTagId: number;data: string[];params?: UnassignTargetsParams}, TContext> => {

const mutationKey = ['unassignTargets'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof unassignTargets>>, {targetTagId: number;data: string[];params?: UnassignTargetsParams}> = (props) => {
          const {targetTagId,data,params} = props ?? {};

          return  unassignTargets(targetTagId,data,params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UnassignTargetsMutationResult = NonNullable<Awaited<ReturnType<typeof unassignTargets>>>
    export type UnassignTargetsMutationBody = string[]
    export type UnassignTargetsMutationError = ExceptionInfo | void

    /**
 * @summary Unassign targets from a given tagId
 */
export const useUnassignTargets = <TError = ExceptionInfo | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof unassignTargets>>, TError,{targetTagId: number;data: string[];params?: UnassignTargetsParams}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof unassignTargets>>,
        TError,
        {targetTagId: number;data: string[];params?: UnassignTargetsParams},
        TContext
      > => {

      const mutationOptions = getUnassignTargetsMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Handles the GET request of retrieving all target tags.
 * @summary Return all target tags
 */
export const getTargetTags = (
    params?: GetTargetTagsParams,
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      
      
      return axiosInstance<PagedListMgmtTag>(
      {url: `/rest/v1/targettags`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getGetTargetTagsQueryKey = (params?: GetTargetTagsParams,) => {
    return [
    `/rest/v1/targettags`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetTargetTagsQueryOptions = <TData = Awaited<ReturnType<typeof getTargetTags>>, TError = ExceptionInfo | PagedListMgmtTag>(params?: GetTargetTagsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTargetTags>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTargetTagsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTargetTags>>> = ({ signal }) => getTargetTags(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getTargetTags>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetTargetTagsQueryResult = NonNullable<Awaited<ReturnType<typeof getTargetTags>>>
export type GetTargetTagsQueryError = ExceptionInfo | PagedListMgmtTag


export function useGetTargetTags<TData = Awaited<ReturnType<typeof getTargetTags>>, TError = ExceptionInfo | PagedListMgmtTag>(
 params: undefined |  GetTargetTagsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTargetTags>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTargetTags>>,
          TError,
          Awaited<ReturnType<typeof getTargetTags>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTargetTags<TData = Awaited<ReturnType<typeof getTargetTags>>, TError = ExceptionInfo | PagedListMgmtTag>(
 params?: GetTargetTagsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTargetTags>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTargetTags>>,
          TError,
          Awaited<ReturnType<typeof getTargetTags>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTargetTags<TData = Awaited<ReturnType<typeof getTargetTags>>, TError = ExceptionInfo | PagedListMgmtTag>(
 params?: GetTargetTagsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTargetTags>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Return all target tags
 */

export function useGetTargetTags<TData = Awaited<ReturnType<typeof getTargetTags>>, TError = ExceptionInfo | PagedListMgmtTag>(
 params?: GetTargetTagsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTargetTags>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetTargetTagsQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Handles the POST request of creating new target tag. The request body must always be a list of target tags.
 * @summary Create target tag(s)
 */
export const createTargetTags = (
    mgmtTagRequestBodyPut: MgmtTagRequestBodyPut[],
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      
      
      return axiosInstance<MgmtTag[]>(
      {url: `/rest/v1/targettags`, method: 'POST',
      headers: {'Content-Type': 'application/hal+json', },
      data: mgmtTagRequestBodyPut, signal
    },
      options);
    }
  


export const getCreateTargetTagsMutationOptions = <TError = ExceptionInfo | MgmtTag[],
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createTargetTags>>, TError,{data: MgmtTagRequestBodyPut[]}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createTargetTags>>, TError,{data: MgmtTagRequestBodyPut[]}, TContext> => {

const mutationKey = ['createTargetTags'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createTargetTags>>, {data: MgmtTagRequestBodyPut[]}> = (props) => {
          const {data} = props ?? {};

          return  createTargetTags(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateTargetTagsMutationResult = NonNullable<Awaited<ReturnType<typeof createTargetTags>>>
    export type CreateTargetTagsMutationBody = MgmtTagRequestBodyPut[]
    export type CreateTargetTagsMutationError = ExceptionInfo | MgmtTag[]

    /**
 * @summary Create target tag(s)
 */
export const useCreateTargetTags = <TError = ExceptionInfo | MgmtTag[],
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createTargetTags>>, TError,{data: MgmtTagRequestBodyPut[]}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createTargetTags>>,
        TError,
        {data: MgmtTagRequestBodyPut[]},
        TContext
      > => {

      const mutationOptions = getCreateTargetTagsMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Handles the POST request of target assignment. Already assigned target will be ignored.
 * @summary Assign target(s) to given tagId
 */
export const assignTarget = (
    targetTagId: number,
    controllerId: string,
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      
      
      return axiosInstance<void>(
      {url: `/rest/v1/targettags/${targetTagId}/assigned/${controllerId}`, method: 'POST', signal
    },
      options);
    }
  


export const getAssignTargetMutationOptions = <TError = ExceptionInfo | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof assignTarget>>, TError,{targetTagId: number;controllerId: string}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof assignTarget>>, TError,{targetTagId: number;controllerId: string}, TContext> => {

const mutationKey = ['assignTarget'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof assignTarget>>, {targetTagId: number;controllerId: string}> = (props) => {
          const {targetTagId,controllerId} = props ?? {};

          return  assignTarget(targetTagId,controllerId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AssignTargetMutationResult = NonNullable<Awaited<ReturnType<typeof assignTarget>>>
    
    export type AssignTargetMutationError = ExceptionInfo | void

    /**
 * @summary Assign target(s) to given tagId
 */
export const useAssignTarget = <TError = ExceptionInfo | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof assignTarget>>, TError,{targetTagId: number;controllerId: string}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof assignTarget>>,
        TError,
        {targetTagId: number;controllerId: string},
        TContext
      > => {

      const mutationOptions = getAssignTargetMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Handles the DELETE request to unassign the given target.
 * @summary Unassign target from a given tagId
 */
export const unassignTarget = (
    targetTagId: number,
    controllerId: string,
 options?: SecondParameter<typeof axiosInstance>,) => {
      
      
      return axiosInstance<void>(
      {url: `/rest/v1/targettags/${targetTagId}/assigned/${controllerId}`, method: 'DELETE'
    },
      options);
    }
  


export const getUnassignTargetMutationOptions = <TError = ExceptionInfo | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof unassignTarget>>, TError,{targetTagId: number;controllerId: string}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof unassignTarget>>, TError,{targetTagId: number;controllerId: string}, TContext> => {

const mutationKey = ['unassignTarget'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof unassignTarget>>, {targetTagId: number;controllerId: string}> = (props) => {
          const {targetTagId,controllerId} = props ?? {};

          return  unassignTarget(targetTagId,controllerId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UnassignTargetMutationResult = NonNullable<Awaited<ReturnType<typeof unassignTarget>>>
    
    export type UnassignTargetMutationError = ExceptionInfo | void

    /**
 * @summary Unassign target from a given tagId
 */
export const useUnassignTarget = <TError = ExceptionInfo | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof unassignTarget>>, TError,{targetTagId: number;controllerId: string}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof unassignTarget>>,
        TError,
        {targetTagId: number;controllerId: string},
        TContext
      > => {

      const mutationOptions = getUnassignTargetMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    